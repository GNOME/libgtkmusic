/* GuitarWidget.c generated by valac 0.18.1, the Vala compiler
 * generated from GuitarWidget.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <gobject/gvaluecollector.h>


#define GTK_MUSIC_TYPE_GUITAR_STRING (gtk_music_guitar_string_get_type ())
#define GTK_MUSIC_GUITAR_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_MUSIC_TYPE_GUITAR_STRING, GtkMusicGuitarString))
#define GTK_MUSIC_GUITAR_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_MUSIC_TYPE_GUITAR_STRING, GtkMusicGuitarStringClass))
#define GTK_MUSIC_IS_GUITAR_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_MUSIC_TYPE_GUITAR_STRING))
#define GTK_MUSIC_IS_GUITAR_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_MUSIC_TYPE_GUITAR_STRING))
#define GTK_MUSIC_GUITAR_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_MUSIC_TYPE_GUITAR_STRING, GtkMusicGuitarStringClass))

typedef struct _GtkMusicGuitarString GtkMusicGuitarString;
typedef struct _GtkMusicGuitarStringClass GtkMusicGuitarStringClass;
typedef struct _GtkMusicGuitarStringPrivate GtkMusicGuitarStringPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _GtkMusicParamSpecGuitarString GtkMusicParamSpecGuitarString;

#define GTK_MUSIC_TYPE_GUITAR_FRET_MARK (gtk_music_guitar_fret_mark_get_type ())
#define GTK_MUSIC_GUITAR_FRET_MARK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_MUSIC_TYPE_GUITAR_FRET_MARK, GtkMusicGuitarFretMark))
#define GTK_MUSIC_GUITAR_FRET_MARK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_MUSIC_TYPE_GUITAR_FRET_MARK, GtkMusicGuitarFretMarkClass))
#define GTK_MUSIC_IS_GUITAR_FRET_MARK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_MUSIC_TYPE_GUITAR_FRET_MARK))
#define GTK_MUSIC_IS_GUITAR_FRET_MARK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_MUSIC_TYPE_GUITAR_FRET_MARK))
#define GTK_MUSIC_GUITAR_FRET_MARK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_MUSIC_TYPE_GUITAR_FRET_MARK, GtkMusicGuitarFretMarkClass))

typedef struct _GtkMusicGuitarFretMark GtkMusicGuitarFretMark;
typedef struct _GtkMusicGuitarFretMarkClass GtkMusicGuitarFretMarkClass;
typedef struct _GtkMusicGuitarFretMarkPrivate GtkMusicGuitarFretMarkPrivate;

#define GTK_MUSIC_GUITAR_FRET_MARK_TYPE_STYLE (gtk_music_guitar_fret_mark_style_get_type ())
typedef struct _GtkMusicParamSpecGuitarFretMark GtkMusicParamSpecGuitarFretMark;

#define GTK_MUSIC_TYPE_GUITAR_POSITION (gtk_music_guitar_position_get_type ())
#define GTK_MUSIC_GUITAR_POSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_MUSIC_TYPE_GUITAR_POSITION, GtkMusicGuitarPosition))
#define GTK_MUSIC_GUITAR_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_MUSIC_TYPE_GUITAR_POSITION, GtkMusicGuitarPositionClass))
#define GTK_MUSIC_IS_GUITAR_POSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_MUSIC_TYPE_GUITAR_POSITION))
#define GTK_MUSIC_IS_GUITAR_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_MUSIC_TYPE_GUITAR_POSITION))
#define GTK_MUSIC_GUITAR_POSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_MUSIC_TYPE_GUITAR_POSITION, GtkMusicGuitarPositionClass))

typedef struct _GtkMusicGuitarPosition GtkMusicGuitarPosition;
typedef struct _GtkMusicGuitarPositionClass GtkMusicGuitarPositionClass;
typedef struct _GtkMusicGuitarPositionPrivate GtkMusicGuitarPositionPrivate;
typedef struct _GtkMusicParamSpecGuitarPosition GtkMusicParamSpecGuitarPosition;

#define GTK_MUSIC_TYPE_GUITAR (gtk_music_guitar_get_type ())
#define GTK_MUSIC_GUITAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_MUSIC_TYPE_GUITAR, GtkMusicGuitar))
#define GTK_MUSIC_GUITAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_MUSIC_TYPE_GUITAR, GtkMusicGuitarClass))
#define GTK_MUSIC_IS_GUITAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_MUSIC_TYPE_GUITAR))
#define GTK_MUSIC_IS_GUITAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_MUSIC_TYPE_GUITAR))
#define GTK_MUSIC_GUITAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_MUSIC_TYPE_GUITAR, GtkMusicGuitarClass))

typedef struct _GtkMusicGuitar GtkMusicGuitar;
typedef struct _GtkMusicGuitarClass GtkMusicGuitarClass;
typedef struct _GtkMusicGuitarPrivate GtkMusicGuitarPrivate;

#define GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE (gtk_music_guitar_marked_note_style_get_type ())
#define GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, GtkMusicGuitarMarkedNoteStyle))
#define GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, GtkMusicGuitarMarkedNoteStyleClass))
#define GTK_MUSIC_GUITAR_IS_MARKED_NOTE_STYLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE))
#define GTK_MUSIC_GUITAR_IS_MARKED_NOTE_STYLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE))
#define GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, GtkMusicGuitarMarkedNoteStyleClass))

typedef struct _GtkMusicGuitarMarkedNoteStyle GtkMusicGuitarMarkedNoteStyle;
typedef struct _GtkMusicGuitarMarkedNoteStyleClass GtkMusicGuitarMarkedNoteStyleClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gtk_music_guitar_string_unref0(var) ((var == NULL) ? NULL : (var = (gtk_music_guitar_string_unref (var), NULL)))
#define _gtk_music_guitar_fret_mark_unref0(var) ((var == NULL) ? NULL : (var = (gtk_music_guitar_fret_mark_unref (var), NULL)))
#define _gtk_music_guitar_marked_note_style_unref0(var) ((var == NULL) ? NULL : (var = (gtk_music_guitar_marked_note_style_unref (var), NULL)))
#define _gtk_music_guitar_position_unref0(var) ((var == NULL) ? NULL : (var = (gtk_music_guitar_position_unref (var), NULL)))
typedef struct _GtkMusicGuitarMarkedNoteStylePrivate GtkMusicGuitarMarkedNoteStylePrivate;
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))
typedef struct _GtkMusicGuitarParamSpecMarkedNoteStyle GtkMusicGuitarParamSpecMarkedNoteStyle;

struct _GtkMusicGuitarString {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GtkMusicGuitarStringPrivate * priv;
	gchar* note;
	gboolean vibrate;
	gdouble vibrateSeed;
	gfloat* color;
	gint color_length1;
	gfloat* labelColor;
	gint labelColor_length1;
};

struct _GtkMusicGuitarStringClass {
	GTypeClass parent_class;
	void (*finalize) (GtkMusicGuitarString *self);
};

struct _GtkMusicParamSpecGuitarString {
	GParamSpec parent_instance;
};

typedef enum  {
	GTK_MUSIC_GUITAR_FRET_MARK_STYLE_NONE,
	GTK_MUSIC_GUITAR_FRET_MARK_STYLE_SOLID_CIRCLE,
	GTK_MUSIC_GUITAR_FRET_MARK_STYLE_RECTANGLE,
	GTK_MUSIC_GUITAR_FRET_MARK_STYLE_FANCY
} GtkMusicGuitarFretMarkStyle;

struct _GtkMusicGuitarFretMark {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GtkMusicGuitarFretMarkPrivate * priv;
	gushort position;
	GtkMusicGuitarFretMarkStyle style;
	gfloat* color;
	gint color_length1;
};

struct _GtkMusicGuitarFretMarkClass {
	GTypeClass parent_class;
	void (*finalize) (GtkMusicGuitarFretMark *self);
};

struct _GtkMusicParamSpecGuitarFretMark {
	GParamSpec parent_instance;
};

struct _GtkMusicGuitarPosition {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GtkMusicGuitarPositionPrivate * priv;
	gushort stringIndex;
	gushort fretIndex;
};

struct _GtkMusicGuitarPositionClass {
	GTypeClass parent_class;
	void (*finalize) (GtkMusicGuitarPosition *self);
};

struct _GtkMusicParamSpecGuitarPosition {
	GParamSpec parent_instance;
};

struct _GtkMusicGuitar {
	GtkDrawingArea parent_instance;
	GtkMusicGuitarPrivate * priv;
	gboolean showLabels;
	gboolean detailedLabels;
	gboolean highlightFirstFret;
	gboolean autoUpdate;
	gushort fretNumber;
	gfloat* gridBgColor;
	gint gridBgColor_length1;
	gfloat* fretColor;
	gint fretColor_length1;
	GeeArrayList* guitarStrings;
	GeeHashSet* fretMarks;
	GeeHashMap* markedNotes;
};

struct _GtkMusicGuitarClass {
	GtkDrawingAreaClass parent_class;
};

struct _GtkMusicGuitarPrivate {
	gboolean shouldAnimate;
	gdouble width;
	gdouble height;
	gdouble gridWidth;
	gdouble gridHeight;
	gdouble gridX;
	gdouble gridY;
	gdouble stringSpacing;
	gdouble fretSpacing;
	gdouble fretMarkRadius;
	gdouble markedNoteRadius;
	gfloat animateInstant;
	gchar** defaultStrings;
	gint defaultStrings_length1;
	gint _defaultStrings_size_;
	gushort* defaultFretMarks;
	gint defaultFretMarks_length1;
	gint _defaultFretMarks_size_;
};

typedef enum  {
	GTK_MUSIC_MUSICAL_NOTE_ERROR_INVALID_NOTE,
	GTK_MUSIC_MUSICAL_NOTE_ERROR_INVALID_MIDI,
	GTK_MUSIC_MUSICAL_NOTE_ERROR_ALREADY_COMPLETE
} GtkMusicMusicalNoteError;
#define GTK_MUSIC_MUSICAL_NOTE_ERROR gtk_music_musical_note_error_quark ()
struct _GtkMusicGuitarMarkedNoteStyle {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GtkMusicGuitarMarkedNoteStylePrivate * priv;
	gfloat* color;
	gint color_length1;
};

struct _GtkMusicGuitarMarkedNoteStyleClass {
	GTypeClass parent_class;
	void (*finalize) (GtkMusicGuitarMarkedNoteStyle *self);
};

struct _GtkMusicGuitarParamSpecMarkedNoteStyle {
	GParamSpec parent_instance;
};


static gpointer gtk_music_guitar_string_parent_class = NULL;
static gpointer gtk_music_guitar_fret_mark_parent_class = NULL;
static gpointer gtk_music_guitar_position_parent_class = NULL;
static gpointer gtk_music_guitar_parent_class = NULL;
static gpointer gtk_music_guitar_marked_note_style_parent_class = NULL;

gpointer gtk_music_guitar_string_ref (gpointer instance);
void gtk_music_guitar_string_unref (gpointer instance);
GParamSpec* gtk_music_param_spec_guitar_string (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gtk_music_value_set_guitar_string (GValue* value, gpointer v_object);
void gtk_music_value_take_guitar_string (GValue* value, gpointer v_object);
gpointer gtk_music_value_get_guitar_string (const GValue* value);
GType gtk_music_guitar_string_get_type (void) G_GNUC_CONST;
enum  {
	GTK_MUSIC_GUITAR_STRING_DUMMY_PROPERTY
};
GtkMusicGuitarString* gtk_music_guitar_string_new (const gchar* note);
GtkMusicGuitarString* gtk_music_guitar_string_construct (GType object_type, const gchar* note);
static void gtk_music_guitar_string_finalize (GtkMusicGuitarString* obj);
gpointer gtk_music_guitar_fret_mark_ref (gpointer instance);
void gtk_music_guitar_fret_mark_unref (gpointer instance);
GParamSpec* gtk_music_param_spec_guitar_fret_mark (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gtk_music_value_set_guitar_fret_mark (GValue* value, gpointer v_object);
void gtk_music_value_take_guitar_fret_mark (GValue* value, gpointer v_object);
gpointer gtk_music_value_get_guitar_fret_mark (const GValue* value);
GType gtk_music_guitar_fret_mark_get_type (void) G_GNUC_CONST;
GType gtk_music_guitar_fret_mark_style_get_type (void) G_GNUC_CONST;
enum  {
	GTK_MUSIC_GUITAR_FRET_MARK_DUMMY_PROPERTY
};
GtkMusicGuitarFretMark* gtk_music_guitar_fret_mark_new (gushort position);
GtkMusicGuitarFretMark* gtk_music_guitar_fret_mark_construct (GType object_type, gushort position);
static void gtk_music_guitar_fret_mark_finalize (GtkMusicGuitarFretMark* obj);
gpointer gtk_music_guitar_position_ref (gpointer instance);
void gtk_music_guitar_position_unref (gpointer instance);
GParamSpec* gtk_music_param_spec_guitar_position (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gtk_music_value_set_guitar_position (GValue* value, gpointer v_object);
void gtk_music_value_take_guitar_position (GValue* value, gpointer v_object);
gpointer gtk_music_value_get_guitar_position (const GValue* value);
GType gtk_music_guitar_position_get_type (void) G_GNUC_CONST;
enum  {
	GTK_MUSIC_GUITAR_POSITION_DUMMY_PROPERTY
};
GtkMusicGuitarPosition* gtk_music_guitar_position_new (gushort stringIndex, gushort fretIndex);
GtkMusicGuitarPosition* gtk_music_guitar_position_construct (GType object_type, gushort stringIndex, gushort fretIndex);
guint gtk_music_guitar_position_hash_func (GtkMusicGuitarPosition* key);
gboolean gtk_music_guitar_position_equal_func (GtkMusicGuitarPosition* a, GtkMusicGuitarPosition* b);
static void gtk_music_guitar_position_finalize (GtkMusicGuitarPosition* obj);
GType gtk_music_guitar_get_type (void) G_GNUC_CONST;
gpointer gtk_music_guitar_marked_note_style_ref (gpointer instance);
void gtk_music_guitar_marked_note_style_unref (gpointer instance);
GParamSpec* gtk_music_guitar_param_spec_marked_note_style (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gtk_music_guitar_value_set_marked_note_style (GValue* value, gpointer v_object);
void gtk_music_guitar_value_take_marked_note_style (GValue* value, gpointer v_object);
gpointer gtk_music_guitar_value_get_marked_note_style (const GValue* value);
GType gtk_music_guitar_marked_note_style_get_type (void) G_GNUC_CONST;
#define GTK_MUSIC_GUITAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GTK_MUSIC_TYPE_GUITAR, GtkMusicGuitarPrivate))
enum  {
	GTK_MUSIC_GUITAR_DUMMY_PROPERTY
};
GtkMusicGuitar* gtk_music_guitar_new (void);
GtkMusicGuitar* gtk_music_guitar_construct (GType object_type);
void gtk_music_guitar_start_animation (GtkMusicGuitar* self);
static gboolean gtk_music_guitar_update_animation (GtkMusicGuitar* self);
static gboolean _gtk_music_guitar_update_animation_gsource_func (gpointer self);
void gtk_music_guitar_stop_animation (GtkMusicGuitar* self);
void gtk_music_guitar_redraw (GtkMusicGuitar* self);
void gtk_music_guitar_mark_position (GtkMusicGuitar* self, gushort stringIndex, gushort fretIndex, gfloat* color, int color_length1);
GtkMusicGuitarMarkedNoteStyle* gtk_music_guitar_marked_note_style_new (gfloat* color, int color_length1);
GtkMusicGuitarMarkedNoteStyle* gtk_music_guitar_marked_note_style_construct (GType object_type, gfloat* color, int color_length1);
void gtk_music_guitar_unmark_position (GtkMusicGuitar* self, gushort stringIndex, gushort fretIndex);
void gtk_music_guitar_unmark_all (GtkMusicGuitar* self);
void gtk_music_guitar_mark_note (GtkMusicGuitar* self, const gchar* note, gfloat* color, int color_length1);
GeeHashSet* gtk_music_guitar_find_positions (GtkMusicGuitar* self, const gchar* note);
void gtk_music_guitar_unmark_note (GtkMusicGuitar* self, const gchar* note);
gshort gtk_music_guitar_note_position_in_string (GtkMusicGuitar* self, gushort stringIndex, const gchar* note);
GQuark gtk_music_musical_note_error_quark (void);
gushort gtk_music_musical_notes_get_note_as_midi_code (const gchar* note, GError** error);
gboolean gtk_music_musical_notes_validate (const gchar* note);
gboolean gtk_music_musical_notes_is_incomplete (const gchar* needle);
GeeHashSet* gtk_music_musical_notes_make (const gchar* incompleteNote, GError** error);
gushort gtk_music_guitar_position_to_midi (GtkMusicGuitar* self, GtkMusicGuitarPosition* position);
gchar* gtk_music_guitar_position_to_note (GtkMusicGuitar* self, GtkMusicGuitarPosition* position);
gchar* gtk_music_musical_notes_get_note_from_midi_code (gushort midi, GError** error);
static GtkMusicGuitarPosition* gtk_music_guitar_point_to_position (GtkMusicGuitar* self, gdouble x, gdouble y);
static gboolean gtk_music_guitar_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static gboolean gtk_music_guitar_real_button_release_event (GtkWidget* base, GdkEventButton* event);
static gboolean gtk_music_guitar_real_draw (GtkWidget* base, cairo_t* cr);
static void gtk_music_guitar_calculate_dimensions (GtkMusicGuitar* self, cairo_t* cr);
static void gtk_music_guitar_draw_base (GtkMusicGuitar* self, cairo_t* cr);
static void gtk_music_guitar_draw_fret_marks (GtkMusicGuitar* self, cairo_t* cr);
static void gtk_music_guitar_draw_frets (GtkMusicGuitar* self, cairo_t* cr);
static void gtk_music_guitar_draw_strings (GtkMusicGuitar* self, cairo_t* cr);
static void gtk_music_guitar_draw_marked_notes (GtkMusicGuitar* self, cairo_t* cr);
static void g_cclosure_user_marshal_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
enum  {
	GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE_DUMMY_PROPERTY
};
static gfloat* _vala_array_dup1 (gfloat* self, int length);
static void gtk_music_guitar_marked_note_style_finalize (GtkMusicGuitarMarkedNoteStyle* obj);
static void gtk_music_guitar_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GtkMusicGuitarString* gtk_music_guitar_string_construct (GType object_type, const gchar* note) {
	GtkMusicGuitarString* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gdouble _tmp2_ = 0.0;
	g_return_val_if_fail (note != NULL, NULL);
	self = (GtkMusicGuitarString*) g_type_create_instance (object_type);
	_tmp0_ = note;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->note);
	self->note = _tmp1_;
	_tmp2_ = g_random_double ();
	self->vibrateSeed = _tmp2_;
	return self;
}


GtkMusicGuitarString* gtk_music_guitar_string_new (const gchar* note) {
	return gtk_music_guitar_string_construct (GTK_MUSIC_TYPE_GUITAR_STRING, note);
}


static void gtk_music_value_guitar_string_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gtk_music_value_guitar_string_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gtk_music_guitar_string_unref (value->data[0].v_pointer);
	}
}


static void gtk_music_value_guitar_string_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gtk_music_guitar_string_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gtk_music_value_guitar_string_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gtk_music_value_guitar_string_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GtkMusicGuitarString* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gtk_music_guitar_string_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gtk_music_value_guitar_string_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GtkMusicGuitarString** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gtk_music_guitar_string_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gtk_music_param_spec_guitar_string (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GtkMusicParamSpecGuitarString* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GTK_MUSIC_TYPE_GUITAR_STRING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gtk_music_value_get_guitar_string (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_STRING), NULL);
	return value->data[0].v_pointer;
}


void gtk_music_value_set_guitar_string (GValue* value, gpointer v_object) {
	GtkMusicGuitarString* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_STRING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_STRING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gtk_music_guitar_string_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_string_unref (old);
	}
}


void gtk_music_value_take_guitar_string (GValue* value, gpointer v_object) {
	GtkMusicGuitarString* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_STRING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_STRING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_string_unref (old);
	}
}


static void gtk_music_guitar_string_class_init (GtkMusicGuitarStringClass * klass) {
	gtk_music_guitar_string_parent_class = g_type_class_peek_parent (klass);
	GTK_MUSIC_GUITAR_STRING_CLASS (klass)->finalize = gtk_music_guitar_string_finalize;
}


static void gtk_music_guitar_string_instance_init (GtkMusicGuitarString * self) {
	gfloat* _tmp0_ = NULL;
	gfloat* _tmp1_ = NULL;
	self->vibrate = FALSE;
	_tmp0_ = g_new0 (gfloat, 4);
	_tmp0_[0] = 0.1f;
	_tmp0_[1] = 0.1f;
	_tmp0_[2] = 0.1f;
	_tmp0_[3] = 1.0f;
	self->color = _tmp0_;
	self->color_length1 = 4;
	_tmp1_ = g_new0 (gfloat, 4);
	_tmp1_[0] = 0.0f;
	_tmp1_[1] = 0.0f;
	_tmp1_[2] = 0.0f;
	_tmp1_[3] = 1.0f;
	self->labelColor = _tmp1_;
	self->labelColor_length1 = 4;
	self->ref_count = 1;
}


static void gtk_music_guitar_string_finalize (GtkMusicGuitarString* obj) {
	GtkMusicGuitarString * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_MUSIC_TYPE_GUITAR_STRING, GtkMusicGuitarString);
	_g_free0 (self->note);
	self->color = (g_free (self->color), NULL);
	self->labelColor = (g_free (self->labelColor), NULL);
}


/**
 * A guitar string with a particular tuning
 **/
GType gtk_music_guitar_string_get_type (void) {
	static volatile gsize gtk_music_guitar_string_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_string_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gtk_music_value_guitar_string_init, gtk_music_value_guitar_string_free_value, gtk_music_value_guitar_string_copy_value, gtk_music_value_guitar_string_peek_pointer, "p", gtk_music_value_guitar_string_collect_value, "p", gtk_music_value_guitar_string_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GtkMusicGuitarStringClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_music_guitar_string_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkMusicGuitarString), 0, (GInstanceInitFunc) gtk_music_guitar_string_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gtk_music_guitar_string_type_id;
		gtk_music_guitar_string_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GtkMusicGuitarString", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gtk_music_guitar_string_type_id__volatile, gtk_music_guitar_string_type_id);
	}
	return gtk_music_guitar_string_type_id__volatile;
}


gpointer gtk_music_guitar_string_ref (gpointer instance) {
	GtkMusicGuitarString* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gtk_music_guitar_string_unref (gpointer instance) {
	GtkMusicGuitarString* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GTK_MUSIC_GUITAR_STRING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GType gtk_music_guitar_fret_mark_style_get_type (void) {
	static volatile gsize gtk_music_guitar_fret_mark_style_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_fret_mark_style_type_id__volatile)) {
		static const GEnumValue values[] = {{GTK_MUSIC_GUITAR_FRET_MARK_STYLE_NONE, "GTK_MUSIC_GUITAR_FRET_MARK_STYLE_NONE", "none"}, {GTK_MUSIC_GUITAR_FRET_MARK_STYLE_SOLID_CIRCLE, "GTK_MUSIC_GUITAR_FRET_MARK_STYLE_SOLID_CIRCLE", "solid-circle"}, {GTK_MUSIC_GUITAR_FRET_MARK_STYLE_RECTANGLE, "GTK_MUSIC_GUITAR_FRET_MARK_STYLE_RECTANGLE", "rectangle"}, {GTK_MUSIC_GUITAR_FRET_MARK_STYLE_FANCY, "GTK_MUSIC_GUITAR_FRET_MARK_STYLE_FANCY", "fancy"}, {0, NULL, NULL}};
		GType gtk_music_guitar_fret_mark_style_type_id;
		gtk_music_guitar_fret_mark_style_type_id = g_enum_register_static ("GtkMusicGuitarFretMarkStyle", values);
		g_once_init_leave (&gtk_music_guitar_fret_mark_style_type_id__volatile, gtk_music_guitar_fret_mark_style_type_id);
	}
	return gtk_music_guitar_fret_mark_style_type_id__volatile;
}


GtkMusicGuitarFretMark* gtk_music_guitar_fret_mark_construct (GType object_type, gushort position) {
	GtkMusicGuitarFretMark* self = NULL;
	gushort _tmp0_;
	self = (GtkMusicGuitarFretMark*) g_type_create_instance (object_type);
	_tmp0_ = position;
	self->position = _tmp0_;
	return self;
}


GtkMusicGuitarFretMark* gtk_music_guitar_fret_mark_new (gushort position) {
	return gtk_music_guitar_fret_mark_construct (GTK_MUSIC_TYPE_GUITAR_FRET_MARK, position);
}


static void gtk_music_value_guitar_fret_mark_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gtk_music_value_guitar_fret_mark_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gtk_music_guitar_fret_mark_unref (value->data[0].v_pointer);
	}
}


static void gtk_music_value_guitar_fret_mark_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gtk_music_guitar_fret_mark_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gtk_music_value_guitar_fret_mark_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gtk_music_value_guitar_fret_mark_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GtkMusicGuitarFretMark* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gtk_music_guitar_fret_mark_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gtk_music_value_guitar_fret_mark_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GtkMusicGuitarFretMark** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gtk_music_guitar_fret_mark_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gtk_music_param_spec_guitar_fret_mark (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GtkMusicParamSpecGuitarFretMark* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GTK_MUSIC_TYPE_GUITAR_FRET_MARK), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gtk_music_value_get_guitar_fret_mark (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_FRET_MARK), NULL);
	return value->data[0].v_pointer;
}


void gtk_music_value_set_guitar_fret_mark (GValue* value, gpointer v_object) {
	GtkMusicGuitarFretMark* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_FRET_MARK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_FRET_MARK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gtk_music_guitar_fret_mark_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_fret_mark_unref (old);
	}
}


void gtk_music_value_take_guitar_fret_mark (GValue* value, gpointer v_object) {
	GtkMusicGuitarFretMark* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_FRET_MARK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_FRET_MARK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_fret_mark_unref (old);
	}
}


static void gtk_music_guitar_fret_mark_class_init (GtkMusicGuitarFretMarkClass * klass) {
	gtk_music_guitar_fret_mark_parent_class = g_type_class_peek_parent (klass);
	GTK_MUSIC_GUITAR_FRET_MARK_CLASS (klass)->finalize = gtk_music_guitar_fret_mark_finalize;
}


static void gtk_music_guitar_fret_mark_instance_init (GtkMusicGuitarFretMark * self) {
	gfloat* _tmp0_ = NULL;
	_tmp0_ = g_new0 (gfloat, 4);
	_tmp0_[0] = 0.8f;
	_tmp0_[1] = 0.8f;
	_tmp0_[2] = 0.8f;
	_tmp0_[3] = 1.0f;
	self->color = _tmp0_;
	self->color_length1 = 4;
	self->ref_count = 1;
}


static void gtk_music_guitar_fret_mark_finalize (GtkMusicGuitarFretMark* obj) {
	GtkMusicGuitarFretMark * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_MUSIC_TYPE_GUITAR_FRET_MARK, GtkMusicGuitarFretMark);
	self->color = (g_free (self->color), NULL);
}


/**
 * A fret mark used to highlight a fret
 **/
GType gtk_music_guitar_fret_mark_get_type (void) {
	static volatile gsize gtk_music_guitar_fret_mark_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_fret_mark_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gtk_music_value_guitar_fret_mark_init, gtk_music_value_guitar_fret_mark_free_value, gtk_music_value_guitar_fret_mark_copy_value, gtk_music_value_guitar_fret_mark_peek_pointer, "p", gtk_music_value_guitar_fret_mark_collect_value, "p", gtk_music_value_guitar_fret_mark_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GtkMusicGuitarFretMarkClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_music_guitar_fret_mark_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkMusicGuitarFretMark), 0, (GInstanceInitFunc) gtk_music_guitar_fret_mark_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gtk_music_guitar_fret_mark_type_id;
		gtk_music_guitar_fret_mark_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GtkMusicGuitarFretMark", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gtk_music_guitar_fret_mark_type_id__volatile, gtk_music_guitar_fret_mark_type_id);
	}
	return gtk_music_guitar_fret_mark_type_id__volatile;
}


gpointer gtk_music_guitar_fret_mark_ref (gpointer instance) {
	GtkMusicGuitarFretMark* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gtk_music_guitar_fret_mark_unref (gpointer instance) {
	GtkMusicGuitarFretMark* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GTK_MUSIC_GUITAR_FRET_MARK_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GtkMusicGuitarPosition* gtk_music_guitar_position_construct (GType object_type, gushort stringIndex, gushort fretIndex) {
	GtkMusicGuitarPosition* self = NULL;
	gushort _tmp0_;
	gushort _tmp1_;
	self = (GtkMusicGuitarPosition*) g_type_create_instance (object_type);
	_tmp0_ = stringIndex;
	self->stringIndex = _tmp0_;
	_tmp1_ = fretIndex;
	self->fretIndex = _tmp1_;
	return self;
}


GtkMusicGuitarPosition* gtk_music_guitar_position_new (gushort stringIndex, gushort fretIndex) {
	return gtk_music_guitar_position_construct (GTK_MUSIC_TYPE_GUITAR_POSITION, stringIndex, fretIndex);
}


guint gtk_music_guitar_position_hash_func (GtkMusicGuitarPosition* key) {
	guint result = 0U;
	GtkMusicGuitarPosition* _tmp0_;
	gushort _tmp1_;
	GtkMusicGuitarPosition* _tmp2_;
	gushort _tmp3_;
	g_return_val_if_fail (key != NULL, 0U);
	_tmp0_ = key;
	_tmp1_ = _tmp0_->stringIndex;
	_tmp2_ = key;
	_tmp3_ = _tmp2_->fretIndex;
	result = (guint) (((13 + _tmp1_) * 23) + _tmp3_);
	return result;
}


gboolean gtk_music_guitar_position_equal_func (GtkMusicGuitarPosition* a, GtkMusicGuitarPosition* b) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkMusicGuitarPosition* _tmp1_;
	gushort _tmp2_;
	GtkMusicGuitarPosition* _tmp3_;
	gushort _tmp4_;
	gboolean _tmp9_;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp1_ = a;
	_tmp2_ = _tmp1_->stringIndex;
	_tmp3_ = b;
	_tmp4_ = _tmp3_->stringIndex;
	if (_tmp2_ == _tmp4_) {
		GtkMusicGuitarPosition* _tmp5_;
		gushort _tmp6_;
		GtkMusicGuitarPosition* _tmp7_;
		gushort _tmp8_;
		_tmp5_ = a;
		_tmp6_ = _tmp5_->fretIndex;
		_tmp7_ = b;
		_tmp8_ = _tmp7_->fretIndex;
		_tmp0_ = _tmp6_ == _tmp8_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp9_ = _tmp0_;
	if (_tmp9_) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static void gtk_music_value_guitar_position_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gtk_music_value_guitar_position_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gtk_music_guitar_position_unref (value->data[0].v_pointer);
	}
}


static void gtk_music_value_guitar_position_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gtk_music_guitar_position_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gtk_music_value_guitar_position_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gtk_music_value_guitar_position_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GtkMusicGuitarPosition* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gtk_music_guitar_position_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gtk_music_value_guitar_position_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GtkMusicGuitarPosition** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gtk_music_guitar_position_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gtk_music_param_spec_guitar_position (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GtkMusicParamSpecGuitarPosition* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GTK_MUSIC_TYPE_GUITAR_POSITION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gtk_music_value_get_guitar_position (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_POSITION), NULL);
	return value->data[0].v_pointer;
}


void gtk_music_value_set_guitar_position (GValue* value, gpointer v_object) {
	GtkMusicGuitarPosition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_POSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_POSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gtk_music_guitar_position_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_position_unref (old);
	}
}


void gtk_music_value_take_guitar_position (GValue* value, gpointer v_object) {
	GtkMusicGuitarPosition* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_TYPE_GUITAR_POSITION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_TYPE_GUITAR_POSITION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_position_unref (old);
	}
}


static void gtk_music_guitar_position_class_init (GtkMusicGuitarPositionClass * klass) {
	gtk_music_guitar_position_parent_class = g_type_class_peek_parent (klass);
	GTK_MUSIC_GUITAR_POSITION_CLASS (klass)->finalize = gtk_music_guitar_position_finalize;
}


static void gtk_music_guitar_position_instance_init (GtkMusicGuitarPosition * self) {
	self->ref_count = 1;
}


static void gtk_music_guitar_position_finalize (GtkMusicGuitarPosition* obj) {
	GtkMusicGuitarPosition * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_MUSIC_TYPE_GUITAR_POSITION, GtkMusicGuitarPosition);
}


/**
 * A guitar position, composed by the string index and the fret index
 **/
GType gtk_music_guitar_position_get_type (void) {
	static volatile gsize gtk_music_guitar_position_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_position_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gtk_music_value_guitar_position_init, gtk_music_value_guitar_position_free_value, gtk_music_value_guitar_position_copy_value, gtk_music_value_guitar_position_peek_pointer, "p", gtk_music_value_guitar_position_collect_value, "p", gtk_music_value_guitar_position_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GtkMusicGuitarPositionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_music_guitar_position_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkMusicGuitarPosition), 0, (GInstanceInitFunc) gtk_music_guitar_position_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gtk_music_guitar_position_type_id;
		gtk_music_guitar_position_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GtkMusicGuitarPosition", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gtk_music_guitar_position_type_id__volatile, gtk_music_guitar_position_type_id);
	}
	return gtk_music_guitar_position_type_id__volatile;
}


gpointer gtk_music_guitar_position_ref (gpointer instance) {
	GtkMusicGuitarPosition* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gtk_music_guitar_position_unref (gpointer instance) {
	GtkMusicGuitarPosition* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GTK_MUSIC_GUITAR_POSITION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


/**
    * Creates a new Guitar widget, which minimum size is defined to 170x60
    **/
GtkMusicGuitar* gtk_music_guitar_construct (GType object_type) {
	GtkMusicGuitar * self = NULL;
	GeeArrayList* _tmp0_;
	GeeHashSet* _tmp1_;
	GeeHashMap* _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gushort* _tmp9_;
	gint _tmp9__length1;
	self = (GtkMusicGuitar*) g_object_new (object_type, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) (GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK));
	gtk_widget_set_size_request ((GtkWidget*) self, 170, 60);
	_tmp0_ = gee_array_list_new (GTK_MUSIC_TYPE_GUITAR_STRING, (GBoxedCopyFunc) gtk_music_guitar_string_ref, gtk_music_guitar_string_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->guitarStrings);
	self->guitarStrings = _tmp0_;
	_tmp1_ = gee_hash_set_new (GTK_MUSIC_TYPE_GUITAR_FRET_MARK, (GBoxedCopyFunc) gtk_music_guitar_fret_mark_ref, gtk_music_guitar_fret_mark_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->fretMarks);
	self->fretMarks = _tmp1_;
	_tmp2_ = gee_hash_map_new (GTK_MUSIC_TYPE_GUITAR_POSITION, (GBoxedCopyFunc) gtk_music_guitar_position_ref, gtk_music_guitar_position_unref, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, (GBoxedCopyFunc) gtk_music_guitar_marked_note_style_ref, gtk_music_guitar_marked_note_style_unref, (GeeHashDataFunc) gtk_music_guitar_position_hash_func, NULL, NULL, (GeeEqualDataFunc) gtk_music_guitar_position_equal_func, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->markedNotes);
	self->markedNotes = _tmp2_;
	_tmp3_ = self->priv->defaultStrings;
	_tmp3__length1 = self->priv->defaultStrings_length1;
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp3_;
		s_collection_length1 = _tmp3__length1;
		for (s_it = 0; s_it < _tmp3__length1; s_it = s_it + 1) {
			gchar* _tmp4_;
			gchar* s = NULL;
			_tmp4_ = g_strdup (s_collection[s_it]);
			s = _tmp4_;
			{
				GeeArrayList* _tmp5_;
				const gchar* _tmp6_;
				GtkMusicGuitarString* _tmp7_;
				GtkMusicGuitarString* _tmp8_;
				_tmp5_ = self->guitarStrings;
				_tmp6_ = s;
				_tmp7_ = gtk_music_guitar_string_new (_tmp6_);
				_tmp8_ = _tmp7_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, _tmp8_);
				_gtk_music_guitar_string_unref0 (_tmp8_);
				_g_free0 (s);
			}
		}
	}
	_tmp9_ = self->priv->defaultFretMarks;
	_tmp9__length1 = self->priv->defaultFretMarks_length1;
	{
		gushort* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp9_;
		i_collection_length1 = _tmp9__length1;
		for (i_it = 0; i_it < _tmp9__length1; i_it = i_it + 1) {
			gushort i = 0U;
			i = i_collection[i_it];
			{
				GeeHashSet* _tmp10_;
				gushort _tmp11_;
				GtkMusicGuitarFretMark* _tmp12_;
				GtkMusicGuitarFretMark* _tmp13_;
				_tmp10_ = self->fretMarks;
				_tmp11_ = i;
				_tmp12_ = gtk_music_guitar_fret_mark_new (_tmp11_);
				_tmp13_ = _tmp12_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, _tmp13_);
				_gtk_music_guitar_fret_mark_unref0 (_tmp13_);
			}
		}
	}
	return self;
}


GtkMusicGuitar* gtk_music_guitar_new (void) {
	return gtk_music_guitar_construct (GTK_MUSIC_TYPE_GUITAR);
}


static gboolean _gtk_music_guitar_update_animation_gsource_func (gpointer self) {
	gboolean result;
	result = gtk_music_guitar_update_animation (self);
	return result;
}


void gtk_music_guitar_start_animation (GtkMusicGuitar* self) {
	g_return_if_fail (self != NULL);
	self->priv->shouldAnimate = TRUE;
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 10, _gtk_music_guitar_update_animation_gsource_func, g_object_ref (self), g_object_unref);
}


void gtk_music_guitar_stop_animation (GtkMusicGuitar* self) {
	g_return_if_fail (self != NULL);
	self->priv->shouldAnimate = FALSE;
	self->priv->animateInstant = (gfloat) 0;
}


static gboolean gtk_music_guitar_update_animation (GtkMusicGuitar* self) {
	gboolean result = FALSE;
	gfloat _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->animateInstant;
	self->priv->animateInstant = _tmp0_ + 0.3f;
	gtk_music_guitar_redraw (self);
	_tmp1_ = self->priv->shouldAnimate;
	result = _tmp1_;
	return result;
}


/**
    * Highlights a position (string and fret) in the instrument
    * @param stringIndex The string number (top string equals to 0)
    * @param fretIndex The fret number
    **/
void gtk_music_guitar_mark_position (GtkMusicGuitar* self, gushort stringIndex, gushort fretIndex, gfloat* color, int color_length1) {
	gushort _tmp0_;
	gushort _tmp1_;
	GtkMusicGuitarPosition* _tmp2_;
	GtkMusicGuitarPosition* key;
	GeeHashMap* _tmp3_;
	GtkMusicGuitarPosition* _tmp4_;
	gfloat* _tmp5_;
	gint _tmp5__length1;
	GtkMusicGuitarMarkedNoteStyle* _tmp6_;
	GtkMusicGuitarMarkedNoteStyle* _tmp7_;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = stringIndex;
	_tmp1_ = fretIndex;
	_tmp2_ = gtk_music_guitar_position_new (_tmp0_, _tmp1_);
	key = _tmp2_;
	_tmp3_ = self->markedNotes;
	_tmp4_ = key;
	_tmp5_ = color;
	_tmp5__length1 = color_length1;
	_tmp6_ = gtk_music_guitar_marked_note_style_new (_tmp5_, _tmp5__length1);
	_tmp7_ = _tmp6_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp3_, _tmp4_, _tmp7_);
	_gtk_music_guitar_marked_note_style_unref0 (_tmp7_);
	_tmp8_ = self->autoUpdate;
	if (_tmp8_) {
		gtk_music_guitar_redraw (self);
	}
	_gtk_music_guitar_position_unref0 (key);
}


/**
    * Removes the mark of a position (string and fret) in the instrument
    * @param stringIndex The string number (top string equals to 0)
    * @param fretIndex The fret number
    **/
void gtk_music_guitar_unmark_position (GtkMusicGuitar* self, gushort stringIndex, gushort fretIndex) {
	gushort _tmp0_;
	gushort _tmp1_;
	GtkMusicGuitarPosition* _tmp2_;
	GtkMusicGuitarPosition* key;
	GeeHashMap* _tmp3_;
	GtkMusicGuitarPosition* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = stringIndex;
	_tmp1_ = fretIndex;
	_tmp2_ = gtk_music_guitar_position_new (_tmp0_, _tmp1_);
	key = _tmp2_;
	_tmp3_ = self->markedNotes;
	_tmp4_ = key;
	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, _tmp4_);
	if (_tmp5_) {
		GeeHashMap* _tmp6_;
		GtkMusicGuitarPosition* _tmp7_;
		_tmp6_ = self->markedNotes;
		_tmp7_ = key;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp6_, _tmp7_, NULL);
	}
	_tmp8_ = self->autoUpdate;
	if (_tmp8_) {
		gtk_music_guitar_redraw (self);
	}
	_gtk_music_guitar_position_unref0 (key);
}


/**
    * Removes all marked notes in the Guitar view
    **/
void gtk_music_guitar_unmark_all (GtkMusicGuitar* self) {
	GeeHashMap* _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->markedNotes;
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp0_);
	_tmp1_ = self->autoUpdate;
	if (_tmp1_) {
		gtk_music_guitar_redraw (self);
	}
}


/**
    * Highlights all positions corresponding to a note
    * @param note A musical note in scientific notation (examples: F#4 , C)
    **/
void gtk_music_guitar_mark_note (GtkMusicGuitar* self, const gchar* note, gfloat* color, int color_length1) {
	gboolean _tmp0_;
	gboolean oldAutoUpdate;
	const gchar* _tmp1_;
	GeeHashSet* _tmp2_ = NULL;
	GeeHashSet* positions;
	GeeHashSet* _tmp3_;
	gboolean _tmp15_;
	gboolean _tmp16_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (note != NULL);
	_tmp0_ = self->autoUpdate;
	oldAutoUpdate = _tmp0_;
	_tmp1_ = note;
	_tmp2_ = gtk_music_guitar_find_positions (self, _tmp1_);
	positions = _tmp2_;
	_tmp3_ = positions;
	if (_tmp3_ == NULL) {
		_g_object_unref0 (positions);
		return;
	}
	{
		GeeHashSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _k_it;
		_tmp4_ = positions;
		_tmp5_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp4_);
		_k_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_;
			gboolean _tmp7_ = FALSE;
			GeeIterator* _tmp8_;
			gpointer _tmp9_ = NULL;
			GtkMusicGuitarPosition* k;
			GtkMusicGuitarPosition* _tmp10_;
			gushort _tmp11_;
			GtkMusicGuitarPosition* _tmp12_;
			gushort _tmp13_;
			gfloat* _tmp14_;
			gint _tmp14__length1;
			_tmp6_ = _k_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _k_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			k = (GtkMusicGuitarPosition*) _tmp9_;
			_tmp10_ = k;
			_tmp11_ = _tmp10_->stringIndex;
			_tmp12_ = k;
			_tmp13_ = _tmp12_->fretIndex;
			_tmp14_ = color;
			_tmp14__length1 = color_length1;
			gtk_music_guitar_mark_position (self, _tmp11_, _tmp13_, _tmp14_, _tmp14__length1);
			_gtk_music_guitar_position_unref0 (k);
		}
		_g_object_unref0 (_k_it);
	}
	_tmp15_ = oldAutoUpdate;
	self->autoUpdate = _tmp15_;
	_tmp16_ = self->autoUpdate;
	if (_tmp16_) {
		gtk_music_guitar_redraw (self);
	}
	_g_object_unref0 (positions);
}


/**
    * Removes the marks in all positions corresponding to a note
    * @param note A musical note in scientific notation (examples: F#4 , C)
    **/
void gtk_music_guitar_unmark_note (GtkMusicGuitar* self, const gchar* note) {
	gboolean _tmp0_;
	gboolean oldAutoUpdate;
	const gchar* _tmp1_;
	GeeHashSet* _tmp2_ = NULL;
	GeeHashSet* positions;
	GeeHashSet* _tmp3_;
	gboolean _tmp14_;
	gboolean _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (note != NULL);
	_tmp0_ = self->autoUpdate;
	oldAutoUpdate = _tmp0_;
	_tmp1_ = note;
	_tmp2_ = gtk_music_guitar_find_positions (self, _tmp1_);
	positions = _tmp2_;
	_tmp3_ = positions;
	if (_tmp3_ == NULL) {
		_g_object_unref0 (positions);
		return;
	}
	{
		GeeHashSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _k_it;
		_tmp4_ = positions;
		_tmp5_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp4_);
		_k_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_;
			gboolean _tmp7_ = FALSE;
			GeeIterator* _tmp8_;
			gpointer _tmp9_ = NULL;
			GtkMusicGuitarPosition* k;
			GtkMusicGuitarPosition* _tmp10_;
			gushort _tmp11_;
			GtkMusicGuitarPosition* _tmp12_;
			gushort _tmp13_;
			_tmp6_ = _k_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _k_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			k = (GtkMusicGuitarPosition*) _tmp9_;
			_tmp10_ = k;
			_tmp11_ = _tmp10_->stringIndex;
			_tmp12_ = k;
			_tmp13_ = _tmp12_->fretIndex;
			gtk_music_guitar_unmark_position (self, _tmp11_, _tmp13_);
			_gtk_music_guitar_position_unref0 (k);
		}
		_g_object_unref0 (_k_it);
	}
	_tmp14_ = oldAutoUpdate;
	self->autoUpdate = _tmp14_;
	_tmp15_ = self->autoUpdate;
	if (_tmp15_) {
		gtk_music_guitar_redraw (self);
	}
	_g_object_unref0 (positions);
}


/**
     * Computes the fret index to accomplish a given note in a given string
     * @param stringIndex The guitar string index
     * @param note The musical note in scientific notation
     * @return The position where the note can be found or -1
     **/
gshort gtk_music_guitar_note_position_in_string (GtkMusicGuitar* self, gushort stringIndex, const gchar* note) {
	gshort result = 0;
	GeeArrayList* _tmp0_;
	gushort _tmp1_;
	gpointer _tmp2_ = NULL;
	GtkMusicGuitarString* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* firstNote;
	const gchar* _tmp7_;
	gushort _tmp8_ = 0U;
	gushort midiA;
	const gchar* _tmp9_;
	gushort _tmp10_ = 0U;
	gushort midiB;
	gushort _tmp11_;
	gushort _tmp12_;
	gshort _result_;
	gshort _tmp13_;
	gushort _tmp14_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (note != NULL, 0);
	_tmp0_ = self->guitarStrings;
	_tmp1_ = stringIndex;
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, (gint) _tmp1_);
	_tmp3_ = (GtkMusicGuitarString*) _tmp2_;
	_tmp4_ = _tmp3_->note;
	_tmp5_ = g_strdup (_tmp4_);
	_tmp6_ = _tmp5_;
	_gtk_music_guitar_string_unref0 (_tmp3_);
	firstNote = _tmp6_;
	_tmp7_ = firstNote;
	_tmp8_ = gtk_music_musical_notes_get_note_as_midi_code (_tmp7_, &_inner_error_);
	midiA = _tmp8_;
	if (_inner_error_ != NULL) {
		_g_free0 (firstNote);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp9_ = note;
	_tmp10_ = gtk_music_musical_notes_get_note_as_midi_code (_tmp9_, &_inner_error_);
	midiB = _tmp10_;
	if (_inner_error_ != NULL) {
		_g_free0 (firstNote);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp11_ = midiB;
	_tmp12_ = midiA;
	_result_ = (gshort) (_tmp11_ - _tmp12_);
	_tmp13_ = _result_;
	_tmp14_ = self->fretNumber;
	if (((gushort) _tmp13_) > _tmp14_) {
		result = (gshort) (-1);
		_g_free0 (firstNote);
		return result;
	}
	result = _result_;
	_g_free0 (firstNote);
	return result;
}


/**
    * Finds all positions of a given note
    * @param note The note with or without the octave component (e.g: A#, D4)
    **/
GeeHashSet* gtk_music_guitar_find_positions (GtkMusicGuitar* self, const gchar* note) {
	GeeHashSet* result = NULL;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_;
	gshort fretIndex = 0;
	GeeHashSet* notesWithOctaves = NULL;
	GeeHashSet* _tmp6_;
	GeeHashSet* validPositions;
	const gchar* _tmp7_;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (note != NULL, NULL);
	_tmp1_ = note;
	_tmp2_ = gtk_music_musical_notes_validate (_tmp1_);
	if (!_tmp2_) {
		const gchar* _tmp3_;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = note;
		_tmp4_ = gtk_music_musical_notes_is_incomplete (_tmp3_);
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		result = NULL;
		return result;
	}
	_tmp6_ = gee_hash_set_new (GTK_MUSIC_TYPE_GUITAR_POSITION, (GBoxedCopyFunc) gtk_music_guitar_position_ref, gtk_music_guitar_position_unref, (GeeHashDataFunc) gtk_music_guitar_position_hash_func, NULL, NULL, (GeeEqualDataFunc) gtk_music_guitar_position_equal_func, NULL, NULL);
	validPositions = _tmp6_;
	_tmp7_ = note;
	_tmp8_ = gtk_music_musical_notes_is_incomplete (_tmp7_);
	if (!_tmp8_) {
		GeeHashSet* _tmp9_;
		GeeHashSet* _tmp10_;
		const gchar* _tmp11_;
		_tmp9_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
		_g_object_unref0 (notesWithOctaves);
		notesWithOctaves = _tmp9_;
		_tmp10_ = notesWithOctaves;
		_tmp11_ = note;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, _tmp11_);
	} else {
		const gchar* _tmp12_;
		GeeHashSet* _tmp13_ = NULL;
		GeeHashSet* _tmp14_;
		_tmp12_ = note;
		_tmp13_ = gtk_music_musical_notes_make (_tmp12_, &_inner_error_);
		_tmp14_ = _tmp13_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (validPositions);
			_g_object_unref0 (notesWithOctaves);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_object_unref0 (notesWithOctaves);
		notesWithOctaves = _tmp14_;
	}
	{
		GeeHashSet* _tmp15_;
		GeeIterator* _tmp16_ = NULL;
		GeeIterator* _n_it;
		_tmp15_ = notesWithOctaves;
		_tmp16_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp15_);
		_n_it = _tmp16_;
		while (TRUE) {
			GeeIterator* _tmp17_;
			gboolean _tmp18_ = FALSE;
			GeeIterator* _tmp19_;
			gpointer _tmp20_ = NULL;
			gchar* n;
			_tmp17_ = _n_it;
			_tmp18_ = gee_iterator_next (_tmp17_);
			if (!_tmp18_) {
				break;
			}
			_tmp19_ = _n_it;
			_tmp20_ = gee_iterator_get (_tmp19_);
			n = (gchar*) _tmp20_;
			{
				gint s;
				s = 0;
				{
					gboolean _tmp21_;
					_tmp21_ = TRUE;
					while (TRUE) {
						gboolean _tmp22_;
						gint _tmp24_;
						GeeArrayList* _tmp25_;
						gint _tmp26_;
						gint _tmp27_;
						gint _tmp28_;
						const gchar* _tmp29_;
						gshort _tmp30_ = 0;
						gshort _tmp31_;
						_tmp22_ = _tmp21_;
						if (!_tmp22_) {
							gint _tmp23_;
							_tmp23_ = s;
							s = _tmp23_ + 1;
						}
						_tmp21_ = FALSE;
						_tmp24_ = s;
						_tmp25_ = self->guitarStrings;
						_tmp26_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp25_);
						_tmp27_ = _tmp26_;
						if (!(_tmp24_ < _tmp27_)) {
							break;
						}
						_tmp28_ = s;
						_tmp29_ = n;
						_tmp30_ = gtk_music_guitar_note_position_in_string (self, (gushort) _tmp28_, _tmp29_);
						fretIndex = _tmp30_;
						_tmp31_ = fretIndex;
						if (((gint) _tmp31_) >= 0) {
							GeeHashSet* _tmp32_;
							gint _tmp33_;
							gshort _tmp34_;
							GtkMusicGuitarPosition* _tmp35_;
							GtkMusicGuitarPosition* _tmp36_;
							_tmp32_ = validPositions;
							_tmp33_ = s;
							_tmp34_ = fretIndex;
							_tmp35_ = gtk_music_guitar_position_new ((gushort) _tmp33_, (gushort) _tmp34_);
							_tmp36_ = _tmp35_;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp36_);
							_gtk_music_guitar_position_unref0 (_tmp36_);
						}
					}
				}
			}
			_g_free0 (n);
		}
		_g_object_unref0 (_n_it);
	}
	result = validPositions;
	_g_object_unref0 (notesWithOctaves);
	return result;
}


/**
    * Gets a MIDI code from a guitar position
    **/
gushort gtk_music_guitar_position_to_midi (GtkMusicGuitar* self, GtkMusicGuitarPosition* position) {
	gushort result = 0U;
	GeeArrayList* _tmp0_;
	GtkMusicGuitarPosition* _tmp1_;
	gushort _tmp2_;
	gpointer _tmp3_ = NULL;
	GtkMusicGuitarString* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* first_note;
	gushort _tmp8_ = 0U;
	gushort midi;
	gushort _tmp9_;
	GtkMusicGuitarPosition* _tmp10_;
	gushort _tmp11_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0U);
	g_return_val_if_fail (position != NULL, 0U);
	_tmp0_ = self->guitarStrings;
	_tmp1_ = position;
	_tmp2_ = _tmp1_->stringIndex;
	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, (gint) _tmp2_);
	_tmp4_ = (GtkMusicGuitarString*) _tmp3_;
	_tmp5_ = _tmp4_->note;
	_tmp6_ = g_strdup (_tmp5_);
	_tmp7_ = _tmp6_;
	_gtk_music_guitar_string_unref0 (_tmp4_);
	first_note = _tmp7_;
	_tmp8_ = gtk_music_musical_notes_get_note_as_midi_code (first_note, &_inner_error_);
	midi = _tmp8_;
	if (_inner_error_ != NULL) {
		_g_free0 (first_note);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0U;
	}
	_tmp9_ = midi;
	_tmp10_ = position;
	_tmp11_ = _tmp10_->fretIndex;
	midi = _tmp9_ + _tmp11_;
	result = midi;
	_g_free0 (first_note);
	return result;
}


/**
    * Convenient function for getting a note name from a guitar position
    **/
gchar* gtk_music_guitar_position_to_note (GtkMusicGuitar* self, GtkMusicGuitarPosition* position) {
	gchar* result = NULL;
	GtkMusicGuitarPosition* _tmp0_;
	gushort _tmp1_ = 0U;
	gushort midi;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (position != NULL, NULL);
	_tmp0_ = position;
	_tmp1_ = gtk_music_guitar_position_to_midi (self, _tmp0_);
	midi = _tmp1_;
	_tmp2_ = gtk_music_musical_notes_get_note_from_midi_code (midi, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _tmp3_;
	return result;
}


/**
     * Finds the guitar position associated to a point
     * @param x The x coordinate of the point
     * @param y The y coordinate of the point
     **/
static GtkMusicGuitarPosition* gtk_music_guitar_point_to_position (GtkMusicGuitar* self, gdouble x, gdouble y) {
	GtkMusicGuitarPosition* result = NULL;
	gfloat x_tolerance;
	gfloat y_tolerance;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	gdouble fretOffset;
	gdouble _tmp7_;
	gdouble _tmp8_;
	gdouble _tmp9_;
	gdouble stringOffset;
	gboolean _tmp10_ = FALSE;
	gdouble _tmp11_;
	gdouble _tmp12_ = 0.0;
	gfloat _tmp13_;
	gboolean _tmp20_;
	gdouble _tmp21_;
	gdouble _tmp22_;
	gushort fretIndex;
	gdouble _tmp23_;
	gdouble _tmp24_;
	gushort stringIndex;
	gdouble _tmp25_;
	gfloat _tmp26_;
	gushort _tmp28_;
	gushort _tmp29_;
	GtkMusicGuitarPosition* _tmp30_;
	g_return_val_if_fail (self != NULL, NULL);
	x_tolerance = 0.4f;
	y_tolerance = 0.2f;
	_tmp0_ = x;
	_tmp1_ = self->priv->gridX;
	x = _tmp0_ - _tmp1_;
	_tmp2_ = y;
	_tmp3_ = self->priv->gridY;
	y = _tmp2_ - _tmp3_;
	_tmp4_ = x;
	_tmp5_ = self->priv->fretSpacing;
	_tmp6_ = self->priv->fretSpacing;
	fretOffset = ((gdouble) fmod (_tmp4_, _tmp5_)) / _tmp6_;
	_tmp7_ = y;
	_tmp8_ = self->priv->stringSpacing;
	_tmp9_ = self->priv->stringSpacing;
	stringOffset = ((gdouble) fmod (_tmp7_, _tmp8_)) / _tmp9_;
	_tmp11_ = fretOffset;
	_tmp12_ = fabs (_tmp11_ - 0.5);
	_tmp13_ = x_tolerance;
	if (_tmp12_ > ((gdouble) _tmp13_)) {
		_tmp10_ = TRUE;
	} else {
		gboolean _tmp14_ = FALSE;
		gdouble _tmp15_;
		gfloat _tmp16_;
		gboolean _tmp19_;
		_tmp15_ = stringOffset;
		_tmp16_ = y_tolerance;
		if (_tmp15_ < ((gdouble) (1 - _tmp16_))) {
			gdouble _tmp17_;
			gfloat _tmp18_;
			_tmp17_ = stringOffset;
			_tmp18_ = y_tolerance;
			_tmp14_ = _tmp17_ > ((gdouble) _tmp18_);
		} else {
			_tmp14_ = FALSE;
		}
		_tmp19_ = _tmp14_;
		_tmp10_ = _tmp19_;
	}
	_tmp20_ = _tmp10_;
	if (_tmp20_) {
		result = NULL;
		return result;
	}
	_tmp21_ = x;
	_tmp22_ = self->priv->fretSpacing;
	fretIndex = (gushort) (_tmp21_ / _tmp22_);
	_tmp23_ = y;
	_tmp24_ = self->priv->stringSpacing;
	stringIndex = (gushort) (_tmp23_ / _tmp24_);
	_tmp25_ = stringOffset;
	_tmp26_ = y_tolerance;
	if (_tmp25_ > ((gdouble) (1 - _tmp26_))) {
		gushort _tmp27_;
		_tmp27_ = stringIndex;
		stringIndex = (gushort) (_tmp27_ + 1);
	}
	_tmp28_ = stringIndex;
	_tmp29_ = fretIndex;
	_tmp30_ = gtk_music_guitar_position_new (_tmp28_, _tmp29_);
	result = _tmp30_;
	return result;
}


/**
    * Customized button_press_event
    *
    * Adds the current position and note to the standard button-press event and
    * emits a note_pressed signal.
    **/
static gboolean gtk_music_guitar_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	GtkMusicGuitar * self;
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	GtkMusicGuitarPosition* _tmp4_ = NULL;
	GtkMusicGuitarPosition* pos;
	GtkMusicGuitarPosition* _tmp5_;
	self = (GtkMusicGuitar*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	_tmp4_ = gtk_music_guitar_point_to_position (self, _tmp1_, _tmp3_);
	pos = _tmp4_;
	_tmp5_ = pos;
	if (_tmp5_ != NULL) {
		GdkEventButton _tmp6_;
		GtkMusicGuitarPosition* _tmp7_;
		_tmp6_ = *event;
		_tmp7_ = pos;
		g_signal_emit_by_name (self, "note-pressed", (GtkWidget*) self, &_tmp6_, _tmp7_);
	}
	result = TRUE;
	_gtk_music_guitar_position_unref0 (pos);
	return result;
}


/**
    * Customized button_released_event
    *
    * Adds the current position and note to the standard button-release event 
    * and emits a note_released signal.
    **/
static gboolean gtk_music_guitar_real_button_release_event (GtkWidget* base, GdkEventButton* event) {
	GtkMusicGuitar * self;
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	gdouble _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	GtkMusicGuitarPosition* _tmp4_ = NULL;
	GtkMusicGuitarPosition* pos;
	GtkMusicGuitarPosition* _tmp5_;
	self = (GtkMusicGuitar*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	_tmp4_ = gtk_music_guitar_point_to_position (self, _tmp1_, _tmp3_);
	pos = _tmp4_;
	_tmp5_ = pos;
	if (_tmp5_ != NULL) {
		GdkEventButton _tmp6_;
		GtkMusicGuitarPosition* _tmp7_;
		_tmp6_ = *event;
		_tmp7_ = pos;
		g_signal_emit_by_name (self, "note-released", (GtkWidget*) self, &_tmp6_, _tmp7_);
	}
	result = TRUE;
	_gtk_music_guitar_position_unref0 (pos);
	return result;
}


/**
    * Draws a guitar widget
    *
    * @param cr The drawing context for the widget
    * @return Whether the event should be propagated (TODO Confirm this theory)
    **/
static gboolean gtk_music_guitar_real_draw (GtkWidget* base, cairo_t* cr) {
	GtkMusicGuitar * self;
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	cairo_t* _tmp2_;
	cairo_t* _tmp3_;
	cairo_t* _tmp4_;
	cairo_t* _tmp5_;
	self = (GtkMusicGuitar*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = cr;
	gtk_music_guitar_calculate_dimensions (self, _tmp0_);
	_tmp1_ = cr;
	gtk_music_guitar_draw_base (self, _tmp1_);
	_tmp2_ = cr;
	gtk_music_guitar_draw_fret_marks (self, _tmp2_);
	_tmp3_ = cr;
	gtk_music_guitar_draw_frets (self, _tmp3_);
	_tmp4_ = cr;
	gtk_music_guitar_draw_strings (self, _tmp4_);
	_tmp5_ = cr;
	gtk_music_guitar_draw_marked_notes (self, _tmp5_);
	result = FALSE;
	return result;
}


/**
    * Calculate some drawing dimensions
    * @param cr The drawing context for the widget
    **/
static void gtk_music_guitar_calculate_dimensions (GtkMusicGuitar* self, cairo_t* cr) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gdouble _tmp2_;
	gboolean _tmp3_;
	gdouble _tmp9_;
	gdouble _tmp10_;
	gdouble _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	GeeArrayList* _tmp14_;
	gint _tmp15_;
	gint _tmp16_;
	gdouble _tmp17_;
	gushort _tmp18_;
	gdouble _tmp19_;
	gdouble _tmp20_;
	gdouble _tmp21_ = 0.0;
	gdouble _tmp22_;
	gdouble _tmp23_;
	gdouble _tmp24_ = 0.0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	self->priv->width = (gdouble) _tmp0_;
	_tmp1_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	self->priv->height = (gdouble) _tmp1_;
	_tmp2_ = self->priv->height;
	self->priv->gridHeight = 0.8 * _tmp2_;
	_tmp3_ = self->showLabels;
	if (_tmp3_) {
		gdouble _tmp4_;
		cairo_t* _tmp5_;
		cairo_t* _tmp6_;
		gdouble _tmp7_;
		_tmp4_ = self->priv->width;
		self->priv->gridWidth = 0.95 * _tmp4_;
		_tmp5_ = cr;
		cairo_select_font_face (_tmp5_, "monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
		_tmp6_ = cr;
		_tmp7_ = self->priv->width;
		cairo_set_font_size (_tmp6_, 0.05 * _tmp7_);
	} else {
		gdouble _tmp8_;
		_tmp8_ = self->priv->width;
		self->priv->gridWidth = _tmp8_;
	}
	_tmp9_ = self->priv->width;
	_tmp10_ = self->priv->gridWidth;
	self->priv->gridX = _tmp9_ - _tmp10_;
	_tmp11_ = self->priv->height;
	_tmp12_ = self->priv->gridHeight;
	self->priv->gridY = (_tmp11_ - _tmp12_) / 2;
	_tmp13_ = self->priv->gridHeight;
	_tmp14_ = self->guitarStrings;
	_tmp15_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp14_);
	_tmp16_ = _tmp15_;
	self->priv->stringSpacing = _tmp13_ / (_tmp16_ - 1);
	_tmp17_ = self->priv->gridWidth;
	_tmp18_ = self->fretNumber;
	self->priv->fretSpacing = _tmp17_ / _tmp18_;
	_tmp19_ = self->priv->fretSpacing;
	_tmp20_ = self->priv->stringSpacing;
	_tmp21_ = fmin (_tmp19_ / 2, _tmp20_ / 2);
	self->priv->fretMarkRadius = 0.5 * _tmp21_;
	_tmp22_ = self->priv->fretSpacing;
	_tmp23_ = self->priv->stringSpacing;
	_tmp24_ = fmin (_tmp22_ / 2, _tmp23_ / 2);
	self->priv->markedNoteRadius = 0.7 * _tmp24_;
}


/**
    * Draw grid background and theme-related stuff
    * @param cr The drawing context for the widget
    **/
static void gtk_music_guitar_draw_base (GtkMusicGuitar* self, cairo_t* cr) {
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat _tmp3_;
	gfloat* _tmp4_;
	gint _tmp4__length1;
	gfloat _tmp5_;
	gfloat* _tmp6_;
	gint _tmp6__length1;
	gfloat _tmp7_;
	gfloat* _tmp8_;
	gint _tmp8__length1;
	gfloat _tmp9_;
	cairo_t* _tmp10_;
	gdouble _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	gdouble _tmp14_;
	gdouble _tmp15_;
	cairo_t* _tmp16_;
	cairo_t* _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = cr;
	cairo_save (_tmp0_);
	_tmp1_ = cr;
	_tmp2_ = self->gridBgColor;
	_tmp2__length1 = self->gridBgColor_length1;
	_tmp3_ = _tmp2_[0];
	_tmp4_ = self->gridBgColor;
	_tmp4__length1 = self->gridBgColor_length1;
	_tmp5_ = _tmp4_[1];
	_tmp6_ = self->gridBgColor;
	_tmp6__length1 = self->gridBgColor_length1;
	_tmp7_ = _tmp6_[2];
	_tmp8_ = self->gridBgColor;
	_tmp8__length1 = self->gridBgColor_length1;
	_tmp9_ = _tmp8_[3];
	cairo_set_source_rgba (_tmp1_, (gdouble) _tmp3_, (gdouble) _tmp5_, (gdouble) _tmp7_, (gdouble) _tmp9_);
	_tmp10_ = cr;
	_tmp11_ = self->priv->gridX;
	_tmp12_ = self->priv->fretSpacing;
	_tmp13_ = self->priv->gridY;
	_tmp14_ = self->priv->gridWidth;
	_tmp15_ = self->priv->gridHeight;
	cairo_rectangle (_tmp10_, _tmp11_ + _tmp12_, _tmp13_, _tmp14_, _tmp15_);
	_tmp16_ = cr;
	cairo_fill (_tmp16_);
	_tmp17_ = cr;
	cairo_restore (_tmp17_);
}


/**
    * Draw guitar strings according to its style properties
    * @param cr The drawing context for the widget
    **/
static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	glong string_length;
	glong _tmp2_;
	glong _tmp5_;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_;
	gboolean _tmp12_;
	gboolean _tmp13_ = FALSE;
	glong _tmp14_;
	gboolean _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_;
		glong _tmp4_;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_;
		glong _tmp7_;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp12_ = _tmp8_;
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp14_ = end;
	if (_tmp14_ >= ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = end;
		_tmp16_ = string_length;
		_tmp13_ = _tmp15_ <= _tmp16_;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp17_ = _tmp13_;
	g_return_val_if_fail (_tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
	_tmp20_ = start;
	_tmp21_ = end;
	_tmp22_ = start;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
	result = _tmp23_;
	return result;
}


static void gtk_music_guitar_draw_strings (GtkMusicGuitar* self, cairo_t* cr) {
	GtkMusicGuitarString* str = NULL;
	gchar* stringLabel = NULL;
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	cairo_t* _tmp88_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = cr;
	cairo_set_line_width (_tmp0_, (gdouble) 2);
	_tmp1_ = cr;
	cairo_save (_tmp1_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				GeeArrayList* _tmp6_;
				gint _tmp7_;
				gint _tmp8_;
				GeeArrayList* _tmp9_;
				gint _tmp10_;
				gpointer _tmp11_ = NULL;
				cairo_t* _tmp12_;
				GtkMusicGuitarString* _tmp13_;
				gfloat* _tmp14_;
				gint _tmp14__length1;
				gfloat _tmp15_;
				GtkMusicGuitarString* _tmp16_;
				gfloat* _tmp17_;
				gint _tmp17__length1;
				gfloat _tmp18_;
				GtkMusicGuitarString* _tmp19_;
				gfloat* _tmp20_;
				gint _tmp20__length1;
				gfloat _tmp21_;
				GtkMusicGuitarString* _tmp22_;
				gfloat* _tmp23_;
				gint _tmp23__length1;
				gfloat _tmp24_;
				gdouble _tmp25_;
				gint _tmp26_;
				gdouble _tmp27_;
				gdouble stringY;
				cairo_t* _tmp28_;
				gdouble _tmp29_;
				gdouble _tmp30_;
				gboolean _tmp31_ = FALSE;
				GtkMusicGuitarString* _tmp32_;
				gboolean _tmp33_;
				gboolean _tmp35_;
				cairo_t* _tmp57_;
				cairo_t* _tmp58_;
				cairo_text_extents_t te = {0};
				gboolean _tmp59_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = self->guitarStrings;
				_tmp7_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp6_);
				_tmp8_ = _tmp7_;
				if (!(_tmp5_ < _tmp8_)) {
					break;
				}
				_tmp9_ = self->guitarStrings;
				_tmp10_ = i;
				_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
				_gtk_music_guitar_string_unref0 (str);
				str = (GtkMusicGuitarString*) _tmp11_;
				_tmp12_ = cr;
				_tmp13_ = str;
				_tmp14_ = _tmp13_->color;
				_tmp14__length1 = _tmp13_->color_length1;
				_tmp15_ = _tmp14_[0];
				_tmp16_ = str;
				_tmp17_ = _tmp16_->color;
				_tmp17__length1 = _tmp16_->color_length1;
				_tmp18_ = _tmp17_[1];
				_tmp19_ = str;
				_tmp20_ = _tmp19_->color;
				_tmp20__length1 = _tmp19_->color_length1;
				_tmp21_ = _tmp20_[2];
				_tmp22_ = str;
				_tmp23_ = _tmp22_->color;
				_tmp23__length1 = _tmp22_->color_length1;
				_tmp24_ = _tmp23_[3];
				cairo_set_source_rgba (_tmp12_, (gdouble) _tmp15_, (gdouble) _tmp18_, (gdouble) _tmp21_, (gdouble) _tmp24_);
				_tmp25_ = self->priv->gridY;
				_tmp26_ = i;
				_tmp27_ = self->priv->stringSpacing;
				stringY = _tmp25_ + (_tmp26_ * _tmp27_);
				_tmp28_ = cr;
				_tmp29_ = self->priv->gridX;
				_tmp30_ = stringY;
				cairo_move_to (_tmp28_, _tmp29_, _tmp30_);
				_tmp32_ = str;
				_tmp33_ = _tmp32_->vibrate;
				if (!_tmp33_) {
					_tmp31_ = TRUE;
				} else {
					gboolean _tmp34_;
					_tmp34_ = self->priv->shouldAnimate;
					_tmp31_ = !_tmp34_;
				}
				_tmp35_ = _tmp31_;
				if (_tmp35_) {
					cairo_t* _tmp36_;
					gdouble _tmp37_;
					gdouble _tmp38_;
					gdouble _tmp39_;
					_tmp36_ = cr;
					_tmp37_ = self->priv->gridX;
					_tmp38_ = self->priv->width;
					_tmp39_ = stringY;
					cairo_line_to (_tmp36_, _tmp37_ + _tmp38_, _tmp39_);
				} else {
					gfloat _tmp40_;
					GtkMusicGuitarString* _tmp41_;
					gdouble _tmp42_;
					gdouble _tmp43_ = 0.0;
					gdouble instant;
					gdouble _tmp44_;
					gdouble _tmp45_;
					gdouble amplitude;
					cairo_t* _tmp46_;
					gdouble _tmp47_;
					gdouble _tmp48_;
					gdouble _tmp49_;
					gdouble _tmp50_;
					gdouble _tmp51_;
					gdouble _tmp52_;
					gdouble _tmp53_;
					gdouble _tmp54_;
					gdouble _tmp55_;
					gdouble _tmp56_;
					_tmp40_ = self->priv->animateInstant;
					_tmp41_ = str;
					_tmp42_ = _tmp41_->vibrateSeed;
					_tmp43_ = sin (_tmp40_ + (4 * _tmp42_));
					instant = _tmp43_;
					_tmp44_ = instant;
					_tmp45_ = self->priv->stringSpacing;
					amplitude = (_tmp44_ * 0.1) * _tmp45_;
					_tmp46_ = cr;
					_tmp47_ = self->priv->gridX;
					_tmp48_ = stringY;
					_tmp49_ = amplitude;
					_tmp50_ = self->priv->gridX;
					_tmp51_ = self->priv->width;
					_tmp52_ = stringY;
					_tmp53_ = amplitude;
					_tmp54_ = self->priv->gridX;
					_tmp55_ = self->priv->width;
					_tmp56_ = stringY;
					cairo_curve_to (_tmp46_, _tmp47_, _tmp48_ + _tmp49_, _tmp50_ + _tmp51_, _tmp52_ + _tmp53_, _tmp54_ + _tmp55_, _tmp56_);
				}
				_tmp57_ = cr;
				cairo_stroke (_tmp57_);
				_tmp58_ = cr;
				cairo_set_source_rgba (_tmp58_, 0.0, 0.0, 0.0, 1.0);
				_tmp59_ = self->showLabels;
				if (_tmp59_) {
					GeeArrayList* _tmp60_;
					gint _tmp61_;
					gpointer _tmp62_ = NULL;
					GtkMusicGuitarString* _tmp63_;
					const gchar* _tmp64_;
					gchar* _tmp65_;
					gboolean _tmp66_;
					cairo_t* _tmp72_;
					const gchar* _tmp73_;
					cairo_text_extents_t _tmp74_ = {0};
					cairo_t* _tmp75_;
					gdouble _tmp76_;
					cairo_text_extents_t _tmp77_;
					gdouble _tmp78_;
					cairo_text_extents_t _tmp79_;
					gdouble _tmp80_;
					gdouble _tmp81_;
					cairo_text_extents_t _tmp82_;
					gdouble _tmp83_;
					cairo_text_extents_t _tmp84_;
					gdouble _tmp85_;
					cairo_t* _tmp86_;
					const gchar* _tmp87_;
					_tmp60_ = self->guitarStrings;
					_tmp61_ = i;
					_tmp62_ = gee_abstract_list_get ((GeeAbstractList*) _tmp60_, _tmp61_);
					_tmp63_ = (GtkMusicGuitarString*) _tmp62_;
					_tmp64_ = _tmp63_->note;
					_tmp65_ = g_strdup (_tmp64_);
					_g_free0 (stringLabel);
					stringLabel = _tmp65_;
					_gtk_music_guitar_string_unref0 (_tmp63_);
					_tmp66_ = self->detailedLabels;
					if (!_tmp66_) {
						const gchar* _tmp67_;
						const gchar* _tmp68_;
						gint _tmp69_;
						gint _tmp70_;
						gchar* _tmp71_ = NULL;
						_tmp67_ = stringLabel;
						_tmp68_ = stringLabel;
						_tmp69_ = strlen (_tmp68_);
						_tmp70_ = _tmp69_;
						_tmp71_ = string_slice (_tmp67_, (glong) 0, (glong) (_tmp70_ - 1));
						_g_free0 (stringLabel);
						stringLabel = _tmp71_;
					}
					_tmp72_ = cr;
					_tmp73_ = stringLabel;
					cairo_text_extents (_tmp72_, _tmp73_, &_tmp74_);
					te = _tmp74_;
					_tmp75_ = cr;
					_tmp76_ = self->priv->gridX;
					_tmp77_ = te;
					_tmp78_ = _tmp77_.x_bearing;
					_tmp79_ = te;
					_tmp80_ = _tmp79_.width;
					_tmp81_ = stringY;
					_tmp82_ = te;
					_tmp83_ = _tmp82_.y_bearing;
					_tmp84_ = te;
					_tmp85_ = _tmp84_.height;
					cairo_move_to (_tmp75_, ((_tmp76_ - 0.5) - _tmp78_) - _tmp80_, ((_tmp81_ + 0.5) - _tmp83_) - (_tmp85_ / 2));
					_tmp86_ = cr;
					_tmp87_ = stringLabel;
					cairo_show_text (_tmp86_, _tmp87_);
				}
			}
		}
	}
	_tmp88_ = cr;
	cairo_restore (_tmp88_);
	_g_free0 (stringLabel);
	_gtk_music_guitar_string_unref0 (str);
}


/**
    * Draw guitar frets
    * @param cr The drawing context for the widget
    **/
static void gtk_music_guitar_draw_frets (GtkMusicGuitar* self, cairo_t* cr) {
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat _tmp3_;
	gfloat* _tmp4_;
	gint _tmp4__length1;
	gfloat _tmp5_;
	gfloat* _tmp6_;
	gint _tmp6__length1;
	gfloat _tmp7_;
	gfloat* _tmp8_;
	gint _tmp8__length1;
	gfloat _tmp9_;
	cairo_t* _tmp25_;
	cairo_t* _tmp26_;
	gboolean _tmp27_;
	cairo_t* _tmp28_;
	cairo_t* _tmp29_;
	gdouble _tmp30_;
	cairo_t* _tmp31_;
	gdouble _tmp32_;
	gdouble _tmp33_;
	gdouble _tmp34_;
	cairo_t* _tmp35_;
	gdouble _tmp36_;
	gdouble _tmp37_;
	gdouble _tmp38_;
	gdouble _tmp39_;
	cairo_t* _tmp40_;
	cairo_t* _tmp41_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = cr;
	cairo_save (_tmp0_);
	_tmp1_ = cr;
	_tmp2_ = self->fretColor;
	_tmp2__length1 = self->fretColor_length1;
	_tmp3_ = _tmp2_[0];
	_tmp4_ = self->fretColor;
	_tmp4__length1 = self->fretColor_length1;
	_tmp5_ = _tmp4_[1];
	_tmp6_ = self->fretColor;
	_tmp6__length1 = self->fretColor_length1;
	_tmp7_ = _tmp6_[2];
	_tmp8_ = self->fretColor;
	_tmp8__length1 = self->fretColor_length1;
	_tmp9_ = _tmp8_[3];
	cairo_set_source_rgba (_tmp1_, (gdouble) _tmp3_, (gdouble) _tmp5_, (gdouble) _tmp7_, (gdouble) _tmp9_);
	{
		gint j;
		j = 1;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_;
				gint _tmp13_;
				gushort _tmp14_;
				gdouble _tmp15_;
				gint _tmp16_;
				gdouble _tmp17_;
				gdouble fretX;
				cairo_t* _tmp18_;
				gdouble _tmp19_;
				gdouble _tmp20_;
				cairo_t* _tmp21_;
				gdouble _tmp22_;
				gdouble _tmp23_;
				gdouble _tmp24_;
				_tmp11_ = _tmp10_;
				if (!_tmp11_) {
					gint _tmp12_;
					_tmp12_ = j;
					j = _tmp12_ + 1;
				}
				_tmp10_ = FALSE;
				_tmp13_ = j;
				_tmp14_ = self->fretNumber;
				if (!(_tmp13_ < ((gint) _tmp14_))) {
					break;
				}
				_tmp15_ = self->priv->gridX;
				_tmp16_ = j;
				_tmp17_ = self->priv->fretSpacing;
				fretX = _tmp15_ + (_tmp16_ * _tmp17_);
				_tmp18_ = cr;
				_tmp19_ = fretX;
				_tmp20_ = self->priv->gridY;
				cairo_move_to (_tmp18_, _tmp19_, _tmp20_);
				_tmp21_ = cr;
				_tmp22_ = fretX;
				_tmp23_ = self->priv->gridY;
				_tmp24_ = self->priv->gridHeight;
				cairo_line_to (_tmp21_, _tmp22_, _tmp23_ + _tmp24_);
			}
		}
	}
	_tmp25_ = cr;
	cairo_stroke (_tmp25_);
	_tmp26_ = cr;
	cairo_restore (_tmp26_);
	_tmp27_ = self->highlightFirstFret;
	if (!_tmp27_) {
		return;
	}
	_tmp28_ = cr;
	cairo_save (_tmp28_);
	_tmp29_ = cr;
	_tmp30_ = self->priv->fretSpacing;
	cairo_set_line_width (_tmp29_, 0.1 * _tmp30_);
	_tmp31_ = cr;
	_tmp32_ = self->priv->gridX;
	_tmp33_ = self->priv->fretSpacing;
	_tmp34_ = self->priv->gridY;
	cairo_move_to (_tmp31_, _tmp32_ + (0.9 * _tmp33_), _tmp34_);
	_tmp35_ = cr;
	_tmp36_ = self->priv->gridX;
	_tmp37_ = self->priv->fretSpacing;
	_tmp38_ = self->priv->gridY;
	_tmp39_ = self->priv->gridHeight;
	cairo_line_to (_tmp35_, _tmp36_ + (0.9 * _tmp37_), _tmp38_ + _tmp39_);
	_tmp40_ = cr;
	cairo_stroke (_tmp40_);
	_tmp41_ = cr;
	cairo_restore (_tmp41_);
}


/**
    * Draw fret marks
    * @param cr The drawing context for the widget
    **/
static void gtk_music_guitar_draw_fret_marks (GtkMusicGuitar* self, cairo_t* cr) {
	GeeHashSet* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	cairo_t* _tmp3_;
	cairo_t* _tmp32_;
	cairo_t* _tmp33_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = self->fretMarks;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 0) {
		return;
	}
	_tmp3_ = cr;
	cairo_save (_tmp3_);
	{
		GeeHashSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _fm_it;
		_tmp4_ = self->fretMarks;
		_tmp5_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp4_);
		_fm_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_;
			gboolean _tmp7_ = FALSE;
			GeeIterator* _tmp8_;
			gpointer _tmp9_ = NULL;
			GtkMusicGuitarFretMark* fm;
			GtkMusicGuitarFretMark* _tmp10_;
			gushort _tmp11_;
			gushort p;
			cairo_t* _tmp12_;
			GtkMusicGuitarFretMark* _tmp13_;
			gfloat* _tmp14_;
			gint _tmp14__length1;
			gfloat _tmp15_;
			GtkMusicGuitarFretMark* _tmp16_;
			gfloat* _tmp17_;
			gint _tmp17__length1;
			gfloat _tmp18_;
			GtkMusicGuitarFretMark* _tmp19_;
			gfloat* _tmp20_;
			gint _tmp20__length1;
			gfloat _tmp21_;
			GtkMusicGuitarFretMark* _tmp22_;
			gfloat* _tmp23_;
			gint _tmp23__length1;
			gfloat _tmp24_;
			cairo_t* _tmp25_;
			gdouble _tmp26_;
			gushort _tmp27_;
			gdouble _tmp28_;
			gdouble _tmp29_;
			gdouble _tmp30_;
			gdouble _tmp31_;
			_tmp6_ = _fm_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _fm_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			fm = (GtkMusicGuitarFretMark*) _tmp9_;
			_tmp10_ = fm;
			_tmp11_ = _tmp10_->position;
			p = _tmp11_;
			_tmp12_ = cr;
			_tmp13_ = fm;
			_tmp14_ = _tmp13_->color;
			_tmp14__length1 = _tmp13_->color_length1;
			_tmp15_ = _tmp14_[0];
			_tmp16_ = fm;
			_tmp17_ = _tmp16_->color;
			_tmp17__length1 = _tmp16_->color_length1;
			_tmp18_ = _tmp17_[1];
			_tmp19_ = fm;
			_tmp20_ = _tmp19_->color;
			_tmp20__length1 = _tmp19_->color_length1;
			_tmp21_ = _tmp20_[2];
			_tmp22_ = fm;
			_tmp23_ = _tmp22_->color;
			_tmp23__length1 = _tmp22_->color_length1;
			_tmp24_ = _tmp23_[3];
			cairo_set_source_rgba (_tmp12_, (gdouble) _tmp15_, (gdouble) _tmp18_, (gdouble) _tmp21_, (gdouble) _tmp24_);
			_tmp25_ = cr;
			_tmp26_ = self->priv->gridX;
			_tmp27_ = p;
			_tmp28_ = self->priv->fretSpacing;
			_tmp29_ = self->priv->gridY;
			_tmp30_ = self->priv->gridHeight;
			_tmp31_ = self->priv->fretMarkRadius;
			cairo_arc (_tmp25_, _tmp26_ + ((_tmp27_ + 0.5) * _tmp28_), _tmp29_ + (_tmp30_ / 2), _tmp31_, (gdouble) 0, 2 * G_PI);
			_gtk_music_guitar_fret_mark_unref0 (fm);
		}
		_g_object_unref0 (_fm_it);
	}
	_tmp32_ = cr;
	cairo_fill (_tmp32_);
	_tmp33_ = cr;
	cairo_restore (_tmp33_);
}


/**
    * Draw marked notes
    * @param cr The drawing context for the widget
    **/
static gpointer _gtk_music_guitar_position_ref0 (gpointer self) {
	return self ? gtk_music_guitar_position_ref (self) : NULL;
}


static gpointer _gtk_music_guitar_marked_note_style_ref0 (gpointer self) {
	return self ? gtk_music_guitar_marked_note_style_ref (self) : NULL;
}


static void gtk_music_guitar_draw_marked_notes (GtkMusicGuitar* self, cairo_t* cr) {
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	cairo_t* _tmp3_;
	cairo_t* _tmp51_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = self->markedNotes;
	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 0) {
		return;
	}
	_tmp3_ = cr;
	cairo_save (_tmp3_);
	{
		GeeHashMap* _tmp4_;
		GeeSet* _tmp5_;
		GeeSet* _tmp6_;
		GeeSet* _tmp7_;
		GeeIterator* _tmp8_ = NULL;
		GeeIterator* _tmp9_;
		GeeIterator* _entry_it;
		_tmp4_ = self->markedNotes;
		_tmp5_ = gee_abstract_map_get_entries ((GeeMap*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = _tmp6_;
		_tmp8_ = gee_iterable_iterator ((GeeIterable*) _tmp7_);
		_tmp9_ = _tmp8_;
		_g_object_unref0 (_tmp7_);
		_entry_it = _tmp9_;
		while (TRUE) {
			GeeIterator* _tmp10_;
			gboolean _tmp11_ = FALSE;
			GeeIterator* _tmp12_;
			gpointer _tmp13_ = NULL;
			GeeMapEntry* entry;
			GeeMapEntry* _tmp14_;
			gconstpointer _tmp15_;
			GtkMusicGuitarPosition* _tmp16_;
			GtkMusicGuitarPosition* _tmp17_;
			GtkMusicGuitarPosition* k;
			GeeMapEntry* _tmp18_;
			gconstpointer _tmp19_;
			GtkMusicGuitarMarkedNoteStyle* _tmp20_;
			GtkMusicGuitarMarkedNoteStyle* _tmp21_;
			GtkMusicGuitarMarkedNoteStyle* v;
			cairo_t* _tmp22_;
			GtkMusicGuitarMarkedNoteStyle* _tmp23_;
			gfloat* _tmp24_;
			gint _tmp24__length1;
			gfloat _tmp25_;
			GtkMusicGuitarMarkedNoteStyle* _tmp26_;
			gfloat* _tmp27_;
			gint _tmp27__length1;
			gfloat _tmp28_;
			GtkMusicGuitarMarkedNoteStyle* _tmp29_;
			gfloat* _tmp30_;
			gint _tmp30__length1;
			gfloat _tmp31_;
			GtkMusicGuitarMarkedNoteStyle* _tmp32_;
			gfloat* _tmp33_;
			gint _tmp33__length1;
			gfloat _tmp34_;
			gdouble _tmp35_;
			GtkMusicGuitarPosition* _tmp36_;
			gushort _tmp37_;
			gdouble _tmp38_;
			gdouble x;
			gdouble _tmp39_;
			GtkMusicGuitarPosition* _tmp40_;
			gushort _tmp41_;
			gdouble _tmp42_;
			gdouble y;
			cairo_t* _tmp43_;
			gdouble _tmp44_;
			gdouble _tmp45_;
			cairo_t* _tmp46_;
			gdouble _tmp47_;
			gdouble _tmp48_;
			gdouble _tmp49_;
			cairo_t* _tmp50_;
			_tmp10_ = _entry_it;
			_tmp11_ = gee_iterator_next (_tmp10_);
			if (!_tmp11_) {
				break;
			}
			_tmp12_ = _entry_it;
			_tmp13_ = gee_iterator_get (_tmp12_);
			entry = (GeeMapEntry*) _tmp13_;
			_tmp14_ = entry;
			_tmp15_ = gee_map_entry_get_key (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = _gtk_music_guitar_position_ref0 ((GtkMusicGuitarPosition*) _tmp16_);
			k = _tmp17_;
			_tmp18_ = entry;
			_tmp19_ = gee_map_entry_get_value (_tmp18_);
			_tmp20_ = _tmp19_;
			_tmp21_ = _gtk_music_guitar_marked_note_style_ref0 ((GtkMusicGuitarMarkedNoteStyle*) _tmp20_);
			v = _tmp21_;
			_tmp22_ = cr;
			_tmp23_ = v;
			_tmp24_ = _tmp23_->color;
			_tmp24__length1 = _tmp23_->color_length1;
			_tmp25_ = _tmp24_[0];
			_tmp26_ = v;
			_tmp27_ = _tmp26_->color;
			_tmp27__length1 = _tmp26_->color_length1;
			_tmp28_ = _tmp27_[1];
			_tmp29_ = v;
			_tmp30_ = _tmp29_->color;
			_tmp30__length1 = _tmp29_->color_length1;
			_tmp31_ = _tmp30_[2];
			_tmp32_ = v;
			_tmp33_ = _tmp32_->color;
			_tmp33__length1 = _tmp32_->color_length1;
			_tmp34_ = _tmp33_[3];
			cairo_set_source_rgba (_tmp22_, (gdouble) _tmp25_, (gdouble) _tmp28_, (gdouble) _tmp31_, (gdouble) _tmp34_);
			_tmp35_ = self->priv->gridX;
			_tmp36_ = k;
			_tmp37_ = _tmp36_->fretIndex;
			_tmp38_ = self->priv->fretSpacing;
			x = _tmp35_ + ((_tmp37_ + 0.5) * _tmp38_);
			_tmp39_ = self->priv->gridY;
			_tmp40_ = k;
			_tmp41_ = _tmp40_->stringIndex;
			_tmp42_ = self->priv->stringSpacing;
			y = _tmp39_ + (_tmp41_ * _tmp42_);
			_tmp43_ = cr;
			_tmp44_ = x;
			_tmp45_ = y;
			cairo_move_to (_tmp43_, _tmp44_, _tmp45_);
			_tmp46_ = cr;
			_tmp47_ = x;
			_tmp48_ = y;
			_tmp49_ = self->priv->markedNoteRadius;
			cairo_arc (_tmp46_, _tmp47_, _tmp48_, _tmp49_, (gdouble) 0, 2 * G_PI);
			_tmp50_ = cr;
			cairo_fill (_tmp50_);
			_gtk_music_guitar_marked_note_style_unref0 (v);
			_gtk_music_guitar_position_unref0 (k);
			_g_object_unref0 (entry);
		}
		_g_object_unref0 (_entry_it);
	}
	_tmp51_ = cr;
	cairo_restore (_tmp51_);
}


/**
    * Forces a complete redraw of the widget
    *
    * This function will invalidate all the region corresponding to the
    * widget's GDK window and ask for updates, forcing a complete redraw.
    *
    **/
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void gtk_music_guitar_redraw (GtkMusicGuitar* self) {
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_;
	GdkWindow* window;
	GdkWindow* _tmp2_;
	GdkWindow* _tmp3_;
	cairo_region_t* _tmp4_ = NULL;
	cairo_region_t* region;
	GdkWindow* _tmp5_;
	cairo_region_t* _tmp6_;
	GdkWindow* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	window = _tmp1_;
	_tmp2_ = window;
	if (NULL == _tmp2_) {
		_g_object_unref0 (window);
		return;
	}
	_tmp3_ = window;
	_tmp4_ = gdk_window_get_clip_region (_tmp3_);
	region = _tmp4_;
	_tmp5_ = window;
	_tmp6_ = region;
	gdk_window_invalidate_region (_tmp5_, _tmp6_, TRUE);
	_tmp7_ = window;
	gdk_window_process_updates (_tmp7_, TRUE);
	_cairo_region_destroy0 (region);
	_g_object_unref0 (window);
}


static void g_cclosure_user_marshal_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer arg_3, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_pointer (param_values + 2), gtk_music_value_get_guitar_position (param_values + 3), data2);
}


static gfloat* _vala_array_dup1 (gfloat* self, int length) {
	return g_memdup (self, length * sizeof (gfloat));
}


GtkMusicGuitarMarkedNoteStyle* gtk_music_guitar_marked_note_style_construct (GType object_type, gfloat* color, int color_length1) {
	GtkMusicGuitarMarkedNoteStyle* self = NULL;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	self = (GtkMusicGuitarMarkedNoteStyle*) g_type_create_instance (object_type);
	_tmp0_ = color;
	_tmp0__length1 = color_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup1 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->color = (g_free (self->color), NULL);
	self->color = _tmp1_;
	self->color_length1 = _tmp1__length1;
	return self;
}


GtkMusicGuitarMarkedNoteStyle* gtk_music_guitar_marked_note_style_new (gfloat* color, int color_length1) {
	return gtk_music_guitar_marked_note_style_construct (GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, color, color_length1);
}


static void gtk_music_guitar_value_marked_note_style_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gtk_music_guitar_value_marked_note_style_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gtk_music_guitar_marked_note_style_unref (value->data[0].v_pointer);
	}
}


static void gtk_music_guitar_value_marked_note_style_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gtk_music_guitar_marked_note_style_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gtk_music_guitar_value_marked_note_style_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gtk_music_guitar_value_marked_note_style_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GtkMusicGuitarMarkedNoteStyle* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gtk_music_guitar_marked_note_style_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gtk_music_guitar_value_marked_note_style_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GtkMusicGuitarMarkedNoteStyle** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gtk_music_guitar_marked_note_style_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* gtk_music_guitar_param_spec_marked_note_style (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GtkMusicGuitarParamSpecMarkedNoteStyle* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer gtk_music_guitar_value_get_marked_note_style (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE), NULL);
	return value->data[0].v_pointer;
}


void gtk_music_guitar_value_set_marked_note_style (GValue* value, gpointer v_object) {
	GtkMusicGuitarMarkedNoteStyle* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gtk_music_guitar_marked_note_style_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_marked_note_style_unref (old);
	}
}


void gtk_music_guitar_value_take_marked_note_style (GValue* value, gpointer v_object) {
	GtkMusicGuitarMarkedNoteStyle* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gtk_music_guitar_marked_note_style_unref (old);
	}
}


static void gtk_music_guitar_marked_note_style_class_init (GtkMusicGuitarMarkedNoteStyleClass * klass) {
	gtk_music_guitar_marked_note_style_parent_class = g_type_class_peek_parent (klass);
	GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE_CLASS (klass)->finalize = gtk_music_guitar_marked_note_style_finalize;
}


static void gtk_music_guitar_marked_note_style_instance_init (GtkMusicGuitarMarkedNoteStyle * self) {
	gfloat* _tmp0_ = NULL;
	_tmp0_ = g_new0 (gfloat, 4);
	_tmp0_[0] = 0.0f;
	_tmp0_[1] = 0.0f;
	_tmp0_[2] = 0.0f;
	_tmp0_[3] = 1.0f;
	self->color = _tmp0_;
	self->color_length1 = 4;
	self->ref_count = 1;
}


static void gtk_music_guitar_marked_note_style_finalize (GtkMusicGuitarMarkedNoteStyle* obj) {
	GtkMusicGuitarMarkedNoteStyle * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_MUSIC_GUITAR_TYPE_MARKED_NOTE_STYLE, GtkMusicGuitarMarkedNoteStyle);
	self->color = (g_free (self->color), NULL);
}


GType gtk_music_guitar_marked_note_style_get_type (void) {
	static volatile gsize gtk_music_guitar_marked_note_style_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_marked_note_style_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gtk_music_guitar_value_marked_note_style_init, gtk_music_guitar_value_marked_note_style_free_value, gtk_music_guitar_value_marked_note_style_copy_value, gtk_music_guitar_value_marked_note_style_peek_pointer, "p", gtk_music_guitar_value_marked_note_style_collect_value, "p", gtk_music_guitar_value_marked_note_style_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GtkMusicGuitarMarkedNoteStyleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_music_guitar_marked_note_style_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkMusicGuitarMarkedNoteStyle), 0, (GInstanceInitFunc) gtk_music_guitar_marked_note_style_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gtk_music_guitar_marked_note_style_type_id;
		gtk_music_guitar_marked_note_style_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GtkMusicGuitarMarkedNoteStyle", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gtk_music_guitar_marked_note_style_type_id__volatile, gtk_music_guitar_marked_note_style_type_id);
	}
	return gtk_music_guitar_marked_note_style_type_id__volatile;
}


gpointer gtk_music_guitar_marked_note_style_ref (gpointer instance) {
	GtkMusicGuitarMarkedNoteStyle* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gtk_music_guitar_marked_note_style_unref (gpointer instance) {
	GtkMusicGuitarMarkedNoteStyle* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GTK_MUSIC_GUITAR_MARKED_NOTE_STYLE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void gtk_music_guitar_class_init (GtkMusicGuitarClass * klass) {
	gtk_music_guitar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GtkMusicGuitarPrivate));
	GTK_WIDGET_CLASS (klass)->button_press_event = gtk_music_guitar_real_button_press_event;
	GTK_WIDGET_CLASS (klass)->button_release_event = gtk_music_guitar_real_button_release_event;
	GTK_WIDGET_CLASS (klass)->draw = gtk_music_guitar_real_draw;
	G_OBJECT_CLASS (klass)->finalize = gtk_music_guitar_finalize;
	g_signal_new ("note_pressed", GTK_MUSIC_TYPE_GUITAR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION, G_TYPE_NONE, 3, GTK_TYPE_WIDGET, G_TYPE_POINTER, GTK_MUSIC_TYPE_GUITAR_POSITION);
	g_signal_new ("note_released", GTK_MUSIC_TYPE_GUITAR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_POINTER_GTK_MUSIC_GUITAR_POSITION, G_TYPE_NONE, 3, GTK_TYPE_WIDGET, G_TYPE_POINTER, GTK_MUSIC_TYPE_GUITAR_POSITION);
}


static void gtk_music_guitar_instance_init (GtkMusicGuitar * self) {
	gfloat* _tmp0_ = NULL;
	gfloat* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar** _tmp8_ = NULL;
	gushort* _tmp9_ = NULL;
	self->priv = GTK_MUSIC_GUITAR_GET_PRIVATE (self);
	self->showLabels = TRUE;
	self->detailedLabels = FALSE;
	self->highlightFirstFret = TRUE;
	self->autoUpdate = TRUE;
	self->priv->shouldAnimate = FALSE;
	self->fretNumber = (gushort) 17;
	_tmp0_ = g_new0 (gfloat, 4);
	_tmp0_[0] = 0.486f;
	_tmp0_[1] = 0.309f;
	_tmp0_[2] = 0.251f;
	_tmp0_[3] = 1.0f;
	self->gridBgColor = _tmp0_;
	self->gridBgColor_length1 = 4;
	_tmp1_ = g_new0 (gfloat, 4);
	_tmp1_[0] = 0.6f;
	_tmp1_[1] = 0.6f;
	_tmp1_[2] = 0.6f;
	_tmp1_[3] = 1.0f;
	self->fretColor = _tmp1_;
	self->fretColor_length1 = 4;
	self->priv->animateInstant = (gfloat) 0;
	_tmp2_ = g_strdup ("E2");
	_tmp3_ = g_strdup ("A2");
	_tmp4_ = g_strdup ("D3");
	_tmp5_ = g_strdup ("G3");
	_tmp6_ = g_strdup ("B3");
	_tmp7_ = g_strdup ("E4");
	_tmp8_ = g_new0 (gchar*, 6 + 1);
	_tmp8_[0] = _tmp2_;
	_tmp8_[1] = _tmp3_;
	_tmp8_[2] = _tmp4_;
	_tmp8_[3] = _tmp5_;
	_tmp8_[4] = _tmp6_;
	_tmp8_[5] = _tmp7_;
	self->priv->defaultStrings = _tmp8_;
	self->priv->defaultStrings_length1 = 6;
	self->priv->_defaultStrings_size_ = self->priv->defaultStrings_length1;
	_tmp9_ = g_new0 (gushort, 8);
	_tmp9_[0] = (gushort) 1;
	_tmp9_[1] = (gushort) 3;
	_tmp9_[2] = (gushort) 5;
	_tmp9_[3] = (gushort) 7;
	_tmp9_[4] = (gushort) 9;
	_tmp9_[5] = (gushort) 12;
	_tmp9_[6] = (gushort) 15;
	_tmp9_[7] = (gushort) 17;
	self->priv->defaultFretMarks = _tmp9_;
	self->priv->defaultFretMarks_length1 = 8;
	self->priv->_defaultFretMarks_size_ = self->priv->defaultFretMarks_length1;
}


static void gtk_music_guitar_finalize (GObject* obj) {
	GtkMusicGuitar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GTK_MUSIC_TYPE_GUITAR, GtkMusicGuitar);
	self->gridBgColor = (g_free (self->gridBgColor), NULL);
	self->fretColor = (g_free (self->fretColor), NULL);
	_g_object_unref0 (self->guitarStrings);
	_g_object_unref0 (self->fretMarks);
	_g_object_unref0 (self->markedNotes);
	self->priv->defaultStrings = (_vala_array_free (self->priv->defaultStrings, self->priv->defaultStrings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->defaultFretMarks = (g_free (self->priv->defaultFretMarks), NULL);
	G_OBJECT_CLASS (gtk_music_guitar_parent_class)->finalize (obj);
}


/**
 * The Guitar widget
 **/
GType gtk_music_guitar_get_type (void) {
	static volatile gsize gtk_music_guitar_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_music_guitar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GtkMusicGuitarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_music_guitar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkMusicGuitar), 0, (GInstanceInitFunc) gtk_music_guitar_instance_init, NULL };
		GType gtk_music_guitar_type_id;
		gtk_music_guitar_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "GtkMusicGuitar", &g_define_type_info, 0);
		g_once_init_leave (&gtk_music_guitar_type_id__volatile, gtk_music_guitar_type_id);
	}
	return gtk_music_guitar_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



